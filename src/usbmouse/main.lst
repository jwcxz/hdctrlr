GAS LISTING /tmp/cc5XZRJy.s 			page 1


   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.stabs	"/home/j/projects/hdctrl/src/usbmouse/",100,0,2,.Ltext0
   8               		.stabs	"main.c",100,0,2,.Ltext0
   9               		.text
  10               	.Ltext0:
  11               		.stabs	"gcc2_compiled.",60,0,0,0
  12               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,0,0
  13               		.stabs	"char:t(0,2)=@s8;r(0,2);0;255;",128,0,0,0
  14               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,0,0
  15               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,0,0
  16               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,0,0
  17               		.stabs	"long long int:t(0,6)=@s64;r(0,6);01000000000000000000000;0777777777777777777777;",128,0,0,
  18               		.stabs	"long long unsigned int:t(0,7)=@s64;r(0,7);0;01777777777777777777777;",128,0,0,0
  19               		.stabs	"short int:t(0,8)=r(0,8);-32768;32767;",128,0,0,0
  20               		.stabs	"short unsigned int:t(0,9)=r(0,9);0;0177777;",128,0,0,0
  21               		.stabs	"signed char:t(0,10)=@s8;r(0,10);-128;127;",128,0,0,0
  22               		.stabs	"unsigned char:t(0,11)=@s8;r(0,11);0;255;",128,0,0,0
  23               		.stabs	"float:t(0,12)=r(0,1);4;0;",128,0,0,0
  24               		.stabs	"double:t(0,13)=r(0,1);4;0;",128,0,0,0
  25               		.stabs	"long double:t(0,14)=r(0,1);4;0;",128,0,0,0
  26               		.stabs	"void:t(0,15)=(0,15)",128,0,0,0
  27               		.stabs	"main.h",130,0,0,0
  28               		.stabs	"/usr/lib/gcc/avr/4.7.1/../../../../avr/include/avr/wdt.h",130,0,0,0
  29               		.stabs	"/usr/lib/gcc/avr/4.7.1/../../../../avr/include/avr/io.h",130,0,0,0
  30               		.stabs	"/usr/lib/gcc/avr/4.7.1/../../../../avr/include/avr/sfr_defs.h",130,0,0,0
  31               		.stabs	"/usr/lib/gcc/avr/4.7.1/../../../../avr/include/inttypes.h",130,0,0,0
  32               		.stabs	"/usr/lib/gcc/avr/4.7.1/include/stdint.h",130,0,0,0
  33               		.stabs	"/usr/lib/gcc/avr/4.7.1/../../../../avr/include/stdint.h",130,0,0,0
  34               		.stabs	"int8_t:t(7,1)=(0,10)",128,0,121,0
  35               		.stabs	"uint8_t:t(7,2)=(0,11)",128,0,122,0
  36               		.stabs	"int16_t:t(7,3)=(0,1)",128,0,123,0
  37               		.stabs	"uint16_t:t(7,4)=(0,4)",128,0,124,0
  38               		.stabs	"int32_t:t(7,5)=(0,3)",128,0,125,0
  39               		.stabs	"uint32_t:t(7,6)=(0,5)",128,0,126,0
  40               		.stabs	"int64_t:t(7,7)=(0,6)",128,0,128,0
  41               		.stabs	"uint64_t:t(7,8)=(0,7)",128,0,129,0
  42               		.stabs	"intptr_t:t(7,9)=(7,3)",128,0,142,0
  43               		.stabs	"uintptr_t:t(7,10)=(7,4)",128,0,147,0
  44               		.stabs	"int_least8_t:t(7,11)=(7,1)",128,0,159,0
  45               		.stabs	"uint_least8_t:t(7,12)=(7,2)",128,0,164,0
  46               		.stabs	"int_least16_t:t(7,13)=(7,3)",128,0,169,0
  47               		.stabs	"uint_least16_t:t(7,14)=(7,4)",128,0,174,0
  48               		.stabs	"int_least32_t:t(7,15)=(7,5)",128,0,179,0
  49               		.stabs	"uint_least32_t:t(7,16)=(7,6)",128,0,184,0
  50               		.stabs	"int_least64_t:t(7,17)=(7,7)",128,0,192,0
  51               		.stabs	"uint_least64_t:t(7,18)=(7,8)",128,0,199,0
  52               		.stabs	"int_fast8_t:t(7,19)=(7,1)",128,0,213,0
  53               		.stabs	"uint_fast8_t:t(7,20)=(7,2)",128,0,218,0
  54               		.stabs	"int_fast16_t:t(7,21)=(7,3)",128,0,223,0
  55               		.stabs	"uint_fast16_t:t(7,22)=(7,4)",128,0,228,0
  56               		.stabs	"int_fast32_t:t(7,23)=(7,5)",128,0,233,0
  57               		.stabs	"uint_fast32_t:t(7,24)=(7,6)",128,0,238,0
GAS LISTING /tmp/cc5XZRJy.s 			page 2


  58               		.stabs	"int_fast64_t:t(7,25)=(7,7)",128,0,246,0
  59               		.stabs	"uint_fast64_t:t(7,26)=(7,8)",128,0,253,0
  60               		.stabs	"intmax_t:t(7,27)=(7,7)",128,0,273,0
  61               		.stabs	"uintmax_t:t(7,28)=(7,8)",128,0,278,0
  62               		.stabn	162,0,0,0
  63               		.stabn	162,0,0,0
  64               		.stabs	"int_farptr_t:t(5,1)=(7,5)",128,0,77,0
  65               		.stabs	"uint_farptr_t:t(5,2)=(7,6)",128,0,81,0
  66               		.stabn	162,0,0,0
  67               		.stabn	162,0,0,0
  68               		.stabs	"/usr/lib/gcc/avr/4.7.1/../../../../avr/include/avr/fuse.h",130,0,0,0
  69               		.stabs	"__fuse_t:t(8,1)=(8,2)=s3low:(0,11),0,8;high:(0,11),8,8;extended:(0,11),16,8;;",128,0,244,0
  70               		.stabn	162,0,0,0
  71               		.stabn	162,0,0,0
  72               		.stabn	162,0,0,0
  73               		.stabs	"/usr/lib/gcc/avr/4.7.1/../../../../avr/include/avr/pgmspace.h",130,0,0,0
  74               		.stabs	"/usr/lib/gcc/avr/4.7.1/include/stddef.h",130,0,0,0
  75               		.stabs	"size_t:t(10,1)=(0,4)",128,0,213,0
  76               		.stabn	162,0,0,0
  77               		.stabn	162,0,0,0
  78               		.stabs	"state:T(1,1)=@s8;enone:0,yellow:1,green:2,blue:3,;",128,0,0,0
  79               		.stabs	"action:T(1,2)=@s8;eidle:0,cw:1,ccw:2,;",128,0,0,0
  80               		.stabn	162,0,0,0
  81               		.stabs	"../lib/usbdrv/usbdrv.h",130,0,0,0
  82               		.stabs	"usbTxStatus:T(11,1)=s12len:(11,2)=B(0,11),0,8;buffer:(11,3)=ar(11,4)=r(11,4);0;0177777;;0;
  83               		.stabs	"usbTxStatus_t:t(11,5)=(11,1)",128,0,650,0
  84               		.stabs	"usbWord:T(11,6)=u2word:(0,4),0,16;bytes:(11,7)=ar(11,4);0;1;(0,11),0,16;;",128,0,0,0
  85               		.stabs	"usbWord_t:t(11,8)=(11,6)",128,0,662,0
  86               		.stabs	"usbRequest:T(11,9)=s8bmRequestType:(0,11),0,8;bRequest:(0,11),8,8;wValue:(11,8),16,16;wInd
  87               		.stabs	"usbRequest_t:t(11,10)=(11,9)",128,0,670,0
  88               		.stabn	162,0,0,0
  89               		.stabs	"report_t:t(0,16)=(0,17)=s4button_mask:(0,11),0,8;dx:(0,2),8,8;dy:(0,2),16,8;d_wheel:(0,2),
  90               		.stabs	"usbFunctionSetup:F(0,11)",36,0,62,usbFunctionSetup
  91               		.stabs	"data:P(0,18)=*(0,11)",64,0,62,24
  92               	.global	usbFunctionSetup
  93               		.type	usbFunctionSetup, @function
  94               	usbFunctionSetup:
  95               		.stabd	46,0,0
   1:main.c        **** // hdctrlr
   2:main.c        **** // reads back emf of a hard drive platter
   3:main.c        **** // spits out some info
   4:main.c        **** //
   5:main.c        **** // http://jwcxz.com/projects/hdctrlr
   6:main.c        **** // J. Colosimo -- http://jwcxz.com
   7:main.c        **** 
   8:main.c        **** #include "main.h"
   9:main.c        **** 
  10:main.c        **** #include "usbdrv.h"
  11:main.c        **** #include "oddebug.h"
  12:main.c        **** 
  13:main.c        **** #include "uart.h"
  14:main.c        **** 
  15:main.c        **** const PROGMEM char usbHidReportDescriptor[52] = { /* USB report descriptor, size must match usbconf
  16:main.c        ****     0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
  17:main.c        ****     0x09, 0x02,                    // USAGE (Mouse)
  18:main.c        ****     0xa1, 0x01,                    // COLLECTION (Application)
  19:main.c        ****     0x09, 0x01,                    //   USAGE (Pointer)
GAS LISTING /tmp/cc5XZRJy.s 			page 3


  20:main.c        ****     0xA1, 0x00,                    //   COLLECTION (Physical)
  21:main.c        ****     0x05, 0x09,                    //     USAGE_PAGE (Button)
  22:main.c        ****     0x19, 0x01,                    //     USAGE_MINIMUM
  23:main.c        ****     0x29, 0x03,                    //     USAGE_MAXIMUM
  24:main.c        ****     0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
  25:main.c        ****     0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
  26:main.c        ****     0x95, 0x03,                    //     REPORT_COUNT (3)
  27:main.c        ****     0x75, 0x01,                    //     REPORT_SIZE (1)
  28:main.c        ****     0x81, 0x02,                    //     INPUT (Data,Var,Abs)
  29:main.c        ****     0x95, 0x01,                    //     REPORT_COUNT (1)
  30:main.c        ****     0x75, 0x05,                    //     REPORT_SIZE (5)
  31:main.c        ****     0x81, 0x03,                    //     INPUT (Const,Var,Abs)
  32:main.c        ****     0x05, 0x01,                    //     USAGE_PAGE (Generic Desktop)
  33:main.c        ****     0x09, 0x30,                    //     USAGE (X)
  34:main.c        ****     0x09, 0x31,                    //     USAGE (Y)
  35:main.c        ****     0x09, 0x38,                    //     USAGE (Wheel)
  36:main.c        ****     0x15, 0x81,                    //     LOGICAL_MINIMUM (-127)
  37:main.c        ****     0x25, 0x7F,                    //     LOGICAL_MAXIMUM (127)
  38:main.c        ****     0x75, 0x08,                    //     REPORT_SIZE (8)
  39:main.c        ****     0x95, 0x03,                    //     REPORT_COUNT (3)
  40:main.c        ****     0x81, 0x06,                    //     INPUT (Data,Var,Rel)
  41:main.c        ****     0xC0,                          //   END_COLLECTION
  42:main.c        ****     0xC0,                          // END COLLECTION
  43:main.c        **** };
  44:main.c        **** 
  45:main.c        **** /* This is the same report descriptor as seen in a Logitech mouse. The data
  46:main.c        ****  * described by this descriptor consists of 4 bytes:
  47:main.c        ****  *      .  .  .  .  . B2 B1 B0 .... one byte with mouse button states
  48:main.c        ****  *     X7 X6 X5 X4 X3 X2 X1 X0 .... 8 bit signed relative coordinate x
  49:main.c        ****  *     Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 .... 8 bit signed relative coordinate y
  50:main.c        ****  *     W7 W6 W5 W4 W3 W2 W1 W0 .... 8 bit signed relative coordinate wheel
  51:main.c        ****  */
  52:main.c        **** typedef struct{
  53:main.c        ****     uchar   button_mask;
  54:main.c        ****     char    dx;
  55:main.c        ****     char    dy;
  56:main.c        ****     char    d_wheel;
  57:main.c        **** }report_t;
  58:main.c        **** 
  59:main.c        **** static report_t report_buf;
  60:main.c        **** static uchar    idleRate;   /* repeat rate for keyboards, never used for mice */
  61:main.c        **** 
  62:main.c        **** usbMsgLen_t usbFunctionSetup(uchar data[8])
  63:main.c        **** {
  96               		.stabn	68,0,63,.LM0-.LFBB1
  97               	.LM0:
  98               	.LFBB1:
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 0 */
 102               	.L__stack_usage = 0
  64:main.c        **** usbRequest_t    *rq = (void *)data;
  65:main.c        **** 
  66:main.c        ****     /* The following requests are never used. But since they are required by
  67:main.c        ****      * the specification, we implement them in this example.
  68:main.c        ****      */
  69:main.c        ****     if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* class request type */
GAS LISTING /tmp/cc5XZRJy.s 			page 4


 103               		.stabn	68,0,69,.LM1-.LFBB1
 104               	.LM1:
 105 0000 FC01      		movw r30,r24
 106 0002 2081      		ld r18,Z
 107 0004 2076      		andi r18,lo8(96)
 108 0006 2032      		cpi r18,lo8(32)
 109 0008 01F0      		breq .L8
 110               	.L6:
  70:main.c        ****         DBG1(0x50, &rq->bRequest, 1);   /* debug output: print our request */
  71:main.c        ****         if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowb
  72:main.c        ****             /* we only have one report type, so don't look at wValue */
  73:main.c        ****             usbMsgPtr = (void *)&report_buf;
  74:main.c        ****             return sizeof(report_buf);
  75:main.c        ****         }else if(rq->bRequest == USBRQ_HID_GET_IDLE){
  76:main.c        ****             usbMsgPtr = &idleRate;
  77:main.c        ****             return 1;
  78:main.c        ****         }else if(rq->bRequest == USBRQ_HID_SET_IDLE){
  79:main.c        ****             idleRate = rq->wValue.bytes[1];
  80:main.c        ****         }
  81:main.c        ****     }else{
  82:main.c        ****         /* no vendor specific requests implemented */
  83:main.c        ****     }
  84:main.c        ****     return 0;   /* default for not implemented requests: return no data back to host */
 111               		.stabn	68,0,84,.LM2-.LFBB1
 112               	.LM2:
 113 000a 80E0      		ldi r24,0
  85:main.c        **** }
 114               		.stabn	68,0,85,.LM3-.LFBB1
 115               	.LM3:
 116 000c 0895      		ret
 117               	.L8:
  71:main.c        ****         if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowb
 118               		.stabn	68,0,71,.LM4-.LFBB1
 119               	.LM4:
 120 000e 2181      		ldd r18,Z+1
 121 0010 2130      		cpi r18,lo8(1)
 122 0012 01F0      		breq .L9
  75:main.c        ****         }else if(rq->bRequest == USBRQ_HID_GET_IDLE){
 123               		.stabn	68,0,75,.LM5-.LFBB1
 124               	.LM5:
 125 0014 2230      		cpi r18,lo8(2)
 126 0016 01F0      		breq .L10
  78:main.c        ****         }else if(rq->bRequest == USBRQ_HID_SET_IDLE){
 127               		.stabn	68,0,78,.LM6-.LFBB1
 128               	.LM6:
 129 0018 2A30      		cpi r18,lo8(10)
 130 001a 01F4      		brne .L6
  79:main.c        ****             idleRate = rq->wValue.bytes[1];
 131               		.stabn	68,0,79,.LM7-.LFBB1
 132               	.LM7:
 133 001c FC01      		movw r30,r24
 134 001e 8381      		ldd r24,Z+3
 135 0020 8093 0000 		sts idleRate,r24
  84:main.c        ****     return 0;   /* default for not implemented requests: return no data back to host */
 136               		.stabn	68,0,84,.LM8-.LFBB1
 137               	.LM8:
 138 0024 80E0      		ldi r24,0
GAS LISTING /tmp/cc5XZRJy.s 			page 5


 139 0026 0895      		ret
 140               	.L9:
  73:main.c        ****             usbMsgPtr = (void *)&report_buf;
 141               		.stabn	68,0,73,.LM9-.LFBB1
 142               	.LM9:
 143 0028 80E0      		ldi r24,lo8(report_buf)
 144 002a 90E0      		ldi r25,hi8(report_buf)
 145 002c 9093 0000 		sts usbMsgPtr+1,r25
 146 0030 8093 0000 		sts usbMsgPtr,r24
  74:main.c        ****             return sizeof(report_buf);
 147               		.stabn	68,0,74,.LM10-.LFBB1
 148               	.LM10:
 149 0034 84E0      		ldi r24,lo8(4)
 150 0036 0895      		ret
 151               	.L10:
  76:main.c        ****             usbMsgPtr = &idleRate;
 152               		.stabn	68,0,76,.LM11-.LFBB1
 153               	.LM11:
 154 0038 80E0      		ldi r24,lo8(idleRate)
 155 003a 90E0      		ldi r25,hi8(idleRate)
 156 003c 9093 0000 		sts usbMsgPtr+1,r25
 157 0040 8093 0000 		sts usbMsgPtr,r24
  77:main.c        ****             return 1;
 158               		.stabn	68,0,77,.LM12-.LFBB1
 159               	.LM12:
 160 0044 81E0      		ldi r24,lo8(1)
 161 0046 0895      		ret
 162               		.size	usbFunctionSetup, .-usbFunctionSetup
 163               	.Lscope1:
 164               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 165               		.stabd	78,0,0
 166               		.section	.text.startup,"ax",@progbits
 167               		.stabs	"main:F(0,1)",36,0,87,main
 168               	.global	main
 169               		.type	main, @function
 170               	main:
 171               		.stabd	46,0,0
  86:main.c        **** 
  87:main.c        **** int main(void) {
 172               		.stabn	68,0,87,.LM13-.LFBB2
 173               	.LM13:
 174               	.LFBB2:
 175 0000 CF93      		push r28
 176 0002 DF93      		push r29
 177 0004 00D0      		rcall .
 178 0006 1F92      		push __zero_reg__
 179 0008 CDB7      		in r28,__SP_L__
 180 000a DEB7      		in r29,__SP_H__
 181               	/* prologue: function */
 182               	/* frame size = 3 */
 183               	/* stack size = 5 */
 184               	.L__stack_usage = 5
  88:main.c        ****     uint8_t i = 0;
  89:main.c        ****     uint8_t samples[3];
  90:main.c        ****     enum state last, curr;
  91:main.c        ****     enum action axn;
  92:main.c        **** 
GAS LISTING /tmp/cc5XZRJy.s 			page 6


  93:main.c        ****     wdt_enable(WDTO_1S);
 185               		.stabn	68,0,93,.LM14-.LFBB2
 186               	.LM14:
 187 000c 2EE0      		ldi r18,lo8(14)
 188 000e 88E1      		ldi r24,lo8(24)
 189 0010 90E0      		ldi r25,0
 190               	/* #APP */
 191               	 ;  93 "main.c" 1
 192 0012 0FB6      		in __tmp_reg__,__SREG__
 193 0014 F894      		cli
 194 0016 A895      		wdr
 195 0018 8093 6000 		sts 96,r24
 196 001c 0FBE      		out __SREG__,__tmp_reg__
 197 001e 2093 6000 		sts 96,r18
 198               		
 199               	 ;  0 "" 2
  94:main.c        **** 
  95:main.c        ****     // initialize USB
  96:main.c        ****     usbInit();
 200               		.stabn	68,0,96,.LM15-.LFBB2
 201               	.LM15:
 202               	/* #NOAPP */
 203 0022 0E94 0000 		call usbInit
  97:main.c        ****     usbDeviceDisconnect();
 204               		.stabn	68,0,97,.LM16-.LFBB2
 205               	.LM16:
 206 0026 549A      		sbi 0xa,4
 207 0028 8FEF      		ldi r24,lo8(-1)
 208               	.L12:
  98:main.c        **** 
  99:main.c        ****     // fake USB disconnect for > 250ms
 100:main.c        ****     while (--i) {
 101:main.c        ****         wdt_reset();
 209               		.stabn	68,0,101,.LM17-.LFBB2
 210               	.LM17:
 211               	/* #APP */
 212               	 ;  101 "main.c" 1
 213 002a A895      		wdr
 214               	 ;  0 "" 2
 215               	/* #NOAPP */
 216               	.LBB4:
 217               	.LBB5:
 218               		.stabs	"/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h",132,0,0,.Ltext1
 219               	.Ltext1:
   1:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
GAS LISTING /tmp/cc5XZRJy.s 			page 7


  14:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
GAS LISTING /tmp/cc5XZRJy.s 			page 8


  71:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
 103:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 104:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /**
 105:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 109:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 112:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 120:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
GAS LISTING /tmp/cc5XZRJy.s 			page 9


 128:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 129:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 132:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 140:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****  */
 141:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** void
 142:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** {
 144:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 156:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 159:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 164:/usr/lib/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 220               		.stabn	68,0,164,.LM18-.LFBB2
 221               	.LM18:
 222 002c E7E8      		ldi r30,lo8(4999)
 223 002e F3E1      		ldi r31,hi8(4999)
 224 0030 3197      		1: sbiw r30,1
 225 0032 01F4      		brne 1b
 226 0034 00C0      		rjmp .
 227 0036 0000      		nop
 228 0038 8150      		subi r24,lo8(-(-1))
 229               	.LBE5:
 230               	.LBE4:
 231               		.stabs	"main.c",132,0,0,.Ltext2
 232               	.Ltext2:
 100:main.c        ****     while (--i) {
 233               		.stabn	68,0,100,.LM19-.LFBB2
 234               	.LM19:
 235 003a 01F4      		brne .L12
 102:main.c        ****         _delay_ms(1);
 103:main.c        ****     }
 104:main.c        **** 
GAS LISTING /tmp/cc5XZRJy.s 			page 10


 105:main.c        ****     usbDeviceConnect();
 236               		.stabn	68,0,105,.LM20-.LFBB2
 237               	.LM20:
 238 003c 5498      		cbi 0xa,4
 106:main.c        ****     sei();
 239               		.stabn	68,0,106,.LM21-.LFBB2
 240               	.LM21:
 241               	/* #APP */
 242               	 ;  106 "main.c" 1
 243 003e 7894      		sei
 244               	 ;  0 "" 2
 107:main.c        **** 
 108:main.c        ****     // initialize UART
 109:main.c        ****     uart_init();
 245               		.stabn	68,0,109,.LM22-.LFBB2
 246               	.LM22:
 247               	/* #NOAPP */
 248 0040 0E94 0000 		call uart_init
 110:main.c        **** 
 111:main.c        ****     // setup ADC
 112:main.c        ****     ADMUX = _BV(ADLAR) | _BV(REFS0);
 249               		.stabn	68,0,112,.LM23-.LFBB2
 250               	.LM23:
 251 0044 80E6      		ldi r24,lo8(96)
 252 0046 8093 7C00 		sts 124,r24
 113:main.c        ****     ADCSRA = _BV(ADEN) | _BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0);
 253               		.stabn	68,0,113,.LM24-.LFBB2
 254               	.LM24:
 255 004a 87E8      		ldi r24,lo8(-121)
 256 004c 8093 7A00 		sts 122,r24
 114:main.c        **** 
 115:main.c        ****     // set state information
 116:main.c        ****     axn = idle;
 257               		.stabn	68,0,116,.LM25-.LFBB2
 258               	.LM25:
 259 0050 00E0      		ldi r16,0
 117:main.c        ****     curr = none;
 118:main.c        ****     last = none;
 260               		.stabn	68,0,118,.LM26-.LFBB2
 261               	.LM26:
 262 0052 10E0      		ldi r17,0
 119:main.c        **** 
 120:main.c        ****     while (1) {
 121:main.c        ****         // read ADCs
 122:main.c        ****         for ( i=0 ; i<3 ; i++ ) {
 123:main.c        ****             ADMUX = _BV(ADLAR) | _BV(REFS0) | i;
 124:main.c        ****             ADCSRA |= _BV(ADSC);
 125:main.c        ****             while ( !(ADCSRA & _BV(ADIF)) );
 126:main.c        ****             ADCSRA |= _BV(ADIF);
 127:main.c        **** 
 128:main.c        ****             // XXX: more resolution needed later?
 129:main.c        ****             samples[i] = ADCH;
 130:main.c        ****         }
 131:main.c        **** 
 132:main.c        ****         // determine current position based on max value of each (and ensure
 133:main.c        ****         // that the value is above the threshold)
 134:main.c        ****         if ( samples[0] > SAMPLE_THRESH && 
GAS LISTING /tmp/cc5XZRJy.s 			page 11


 135:main.c        ****                 samples[0] > samples[1] && 
 136:main.c        ****                 samples[0] > samples[2] ) {
 137:main.c        ****             curr = yellow;
 138:main.c        ****         } else if ( samples[1] > SAMPLE_THRESH && 
 139:main.c        ****                 samples[1] > samples[0] && 
 140:main.c        ****                 samples[1] > samples[2] ) {
 141:main.c        ****             curr = blue;
 142:main.c        ****         } else if ( samples[2] > SAMPLE_THRESH && 
 143:main.c        ****                 samples[2] > samples[0] && 
 144:main.c        ****                 samples[2] > samples[1] ) {
 145:main.c        ****             curr = green;
 146:main.c        ****         } else {
 147:main.c        ****             curr = none;
 148:main.c        ****         }
 149:main.c        ****         
 150:main.c        **** 
 151:main.c        ****         switch (last) {
 152:main.c        ****             case none:
 153:main.c        ****                 // no previous information known
 154:main.c        ****                 break;
 155:main.c        **** 
 156:main.c        ****             case yellow:
 157:main.c        ****                 switch (curr) {
 158:main.c        ****                     case none:
 159:main.c        ****                         axn = idle;
 160:main.c        ****                         break;
 161:main.c        ****                     case yellow:
 162:main.c        ****                         axn = idle;
 163:main.c        ****                         break;
 164:main.c        ****                     case blue:
 165:main.c        ****                         axn = cw;
 166:main.c        ****                         break;
 167:main.c        ****                     case green:
 168:main.c        ****                         axn = ccw;
 169:main.c        ****                         break;
 170:main.c        ****                 }
 171:main.c        ****                 break;
 172:main.c        **** 
 173:main.c        ****             case blue:
 174:main.c        ****                 switch (curr) {
 175:main.c        ****                     case none:
 176:main.c        ****                         axn = idle;
 177:main.c        ****                         break;
 178:main.c        ****                     case yellow:
 179:main.c        ****                         axn = ccw;
 180:main.c        ****                         break;
 181:main.c        ****                     case blue:
 182:main.c        ****                         axn = idle;
 183:main.c        ****                         break;
 184:main.c        ****                     case green:
 185:main.c        ****                         axn = cw;
 186:main.c        ****                         break;
 187:main.c        ****                 }
 188:main.c        ****                 break;
 189:main.c        **** 
 190:main.c        ****             case green:
 191:main.c        ****                 switch (curr) {
GAS LISTING /tmp/cc5XZRJy.s 			page 12


 192:main.c        ****                     case none:
 193:main.c        ****                         axn = idle;
 194:main.c        ****                         break;
 195:main.c        ****                     case yellow:
 196:main.c        ****                         axn = cw;
 197:main.c        ****                         break;
 198:main.c        ****                     case blue:
 199:main.c        ****                         axn = ccw;
 200:main.c        ****                         break;
 201:main.c        ****                     case green:
 202:main.c        ****                         axn = idle;
 203:main.c        ****                         break;
 204:main.c        ****                 }
 205:main.c        ****                 break;
 206:main.c        ****         }
 207:main.c        **** 
 208:main.c        ****         if ( last == none || curr != none ) {
 209:main.c        ****             last = curr;
 210:main.c        ****         }
 211:main.c        **** 
 212:main.c        ****         if ( axn == cw ) {
 213:main.c        ****             uart_tx('>');
 214:main.c        ****             report_buf.button_mask = _BV(7);
 215:main.c        ****             usbSetInterrupt((void *)&report_buf, sizeof(report_buf));
 216:main.c        ****         } else if ( axn == ccw ) {
 217:main.c        ****             uart_tx('<');
 218:main.c        ****             report_buf.button_mask = _BV(6);
 263               		.stabn	68,0,218,.LM27-.LFBB2
 264               	.LM27:
 265 0054 80E4      		ldi r24,lo8(64)
 266 0056 E82E      		mov r14,r24
 214:main.c        ****             report_buf.button_mask = _BV(7);
 267               		.stabn	68,0,214,.LM28-.LFBB2
 268               	.LM28:
 269 0058 90E8      		ldi r25,lo8(-128)
 270 005a F92E      		mov r15,r25
 271               	.L57:
 272 005c FE01      		movw r30,r28
 273 005e 3196      		adiw r30,1
 122:main.c        ****         for ( i=0 ; i<3 ; i++ ) {
 274               		.stabn	68,0,122,.LM29-.LFBB2
 275               	.LM29:
 276 0060 90E0      		ldi r25,0
 277               	.L15:
 123:main.c        ****             ADMUX = _BV(ADLAR) | _BV(REFS0) | i;
 278               		.stabn	68,0,123,.LM30-.LFBB2
 279               	.LM30:
 280 0062 892F      		mov r24,r25
 281 0064 8066      		ori r24,lo8(96)
 282 0066 8093 7C00 		sts 124,r24
 124:main.c        ****             ADCSRA |= _BV(ADSC);
 283               		.stabn	68,0,124,.LM31-.LFBB2
 284               	.LM31:
 285 006a 8091 7A00 		lds r24,122
 286 006e 8064      		ori r24,lo8(64)
 287 0070 8093 7A00 		sts 122,r24
 288               	.L14:
GAS LISTING /tmp/cc5XZRJy.s 			page 13


 125:main.c        ****             while ( !(ADCSRA & _BV(ADIF)) );
 289               		.stabn	68,0,125,.LM32-.LFBB2
 290               	.LM32:
 291 0074 8091 7A00 		lds r24,122
 292 0078 84FF      		sbrs r24,4
 293 007a 00C0      		rjmp .L14
 126:main.c        ****             ADCSRA |= _BV(ADIF);
 294               		.stabn	68,0,126,.LM33-.LFBB2
 295               	.LM33:
 296 007c 8091 7A00 		lds r24,122
 297 0080 8061      		ori r24,lo8(16)
 298 0082 8093 7A00 		sts 122,r24
 129:main.c        ****             samples[i] = ADCH;
 299               		.stabn	68,0,129,.LM34-.LFBB2
 300               	.LM34:
 301 0086 8091 7900 		lds r24,121
 302 008a 8193      		st Z+,r24
 122:main.c        ****         for ( i=0 ; i<3 ; i++ ) {
 303               		.stabn	68,0,122,.LM35-.LFBB2
 304               	.LM35:
 305 008c 9F5F      		subi r25,lo8(-(1))
 306 008e 9330      		cpi r25,lo8(3)
 307 0090 01F4      		brne .L15
 134:main.c        ****         if ( samples[0] > SAMPLE_THRESH && 
 308               		.stabn	68,0,134,.LM36-.LFBB2
 309               	.LM36:
 310 0092 8981      		ldd r24,Y+1
 135:main.c        ****                 samples[0] > samples[1] && 
 311               		.stabn	68,0,135,.LM37-.LFBB2
 312               	.LM37:
 313 0094 9A81      		ldd r25,Y+2
 136:main.c        ****                 samples[0] > samples[2] ) {
 314               		.stabn	68,0,136,.LM38-.LFBB2
 315               	.LM38:
 316 0096 2B81      		ldd r18,Y+3
 134:main.c        ****         if ( samples[0] > SAMPLE_THRESH && 
 317               		.stabn	68,0,134,.LM39-.LFBB2
 318               	.LM39:
 319 0098 8131      		cpi r24,lo8(17)
 320 009a 00F0      		brlo .L17
 134:main.c        ****         if ( samples[0] > SAMPLE_THRESH && 
 321               		.stabn	68,0,134,.LM40-.LFBB2
 322               	.LM40:
 323 009c 9817      		cp r25,r24
 324 009e 00F4      		brsh .L17
 135:main.c        ****                 samples[0] > samples[1] && 
 325               		.stabn	68,0,135,.LM41-.LFBB2
 326               	.LM41:
 327 00a0 2817      		cp r18,r24
 328 00a2 00F4      		brsh .L17
 137:main.c        ****             curr = yellow;
 329               		.stabn	68,0,137,.LM42-.LFBB2
 330               	.LM42:
 331 00a4 81E0      		ldi r24,lo8(1)
 332               	.L19:
 151:main.c        ****         switch (last) {
 333               		.stabn	68,0,151,.LM43-.LFBB2
GAS LISTING /tmp/cc5XZRJy.s 			page 14


 334               	.LM43:
 335 00a6 1230      		cpi r17,lo8(2)
 336 00a8 01F0      		breq .L23
 337               	.L62:
 338 00aa 1330      		cpi r17,lo8(3)
 339 00ac 01F0      		breq .L24
 340 00ae 1130      		cpi r17,lo8(1)
 341 00b0 01F0      		breq .L59
 208:main.c        ****         if ( last == none || curr != none ) {
 342               		.stabn	68,0,208,.LM44-.LFBB2
 343               	.LM44:
 344 00b2 1111      		cpse r17,__zero_reg__
 345 00b4 00C0      		rjmp .L36
 346               	.L46:
 347 00b6 182F      		mov r17,r24
 212:main.c        ****         if ( axn == cw ) {
 348               		.stabn	68,0,212,.LM45-.LFBB2
 349               	.LM45:
 350 00b8 0130      		cpi r16,lo8(1)
 351 00ba 01F0      		breq .L60
 352               	.L33:
 216:main.c        ****         } else if ( axn == ccw ) {
 353               		.stabn	68,0,216,.LM46-.LFBB2
 354               	.LM46:
 355 00bc 0230      		cpi r16,lo8(2)
 356 00be 01F0      		breq .L61
 219:main.c        ****             usbSetInterrupt((void *)&report_buf, sizeof(report_buf));
 220:main.c        ****         } else {
 221:main.c        ****             report_buf.button_mask = 0;
 357               		.stabn	68,0,221,.LM47-.LFBB2
 358               	.LM47:
 359 00c0 1092 0000 		sts report_buf,__zero_reg__
 360 00c4 00C0      		rjmp .L57
 361               	.L17:
 138:main.c        ****         } else if ( samples[1] > SAMPLE_THRESH && 
 362               		.stabn	68,0,138,.LM48-.LFBB2
 363               	.LM48:
 364 00c6 9131      		cpi r25,lo8(17)
 365 00c8 00F0      		brlo .L20
 138:main.c        ****         } else if ( samples[1] > SAMPLE_THRESH && 
 366               		.stabn	68,0,138,.LM49-.LFBB2
 367               	.LM49:
 368 00ca 8917      		cp r24,r25
 369 00cc 00F4      		brsh .L20
 139:main.c        ****                 samples[1] > samples[0] && 
 370               		.stabn	68,0,139,.LM50-.LFBB2
 371               	.LM50:
 372 00ce 2917      		cp r18,r25
 373 00d0 00F4      		brsh .L20
 141:main.c        ****             curr = blue;
 374               		.stabn	68,0,141,.LM51-.LFBB2
 375               	.LM51:
 376 00d2 83E0      		ldi r24,lo8(3)
 151:main.c        ****         switch (last) {
 377               		.stabn	68,0,151,.LM52-.LFBB2
 378               	.LM52:
 379 00d4 1230      		cpi r17,lo8(2)
GAS LISTING /tmp/cc5XZRJy.s 			page 15


 380 00d6 01F4      		brne .L62
 381               	.L23:
 191:main.c        ****                 switch (curr) {
 382               		.stabn	68,0,191,.LM53-.LFBB2
 383               	.LM53:
 384 00d8 8130      		cpi r24,lo8(1)
 385 00da 01F0      		breq .L30
 386 00dc 8330      		cpi r24,lo8(3)
 387 00de 01F0      		breq .L42
 388               	.L56:
 193:main.c        ****                         axn = idle;
 389               		.stabn	68,0,193,.LM54-.LFBB2
 390               	.LM54:
 391 00e0 00E0      		ldi r16,0
 392               	.L36:
 208:main.c        ****         if ( last == none || curr != none ) {
 393               		.stabn	68,0,208,.LM55-.LFBB2
 394               	.LM55:
 395 00e2 8111      		cpse r24,__zero_reg__
 396 00e4 00C0      		rjmp .L46
 212:main.c        ****         if ( axn == cw ) {
 397               		.stabn	68,0,212,.LM56-.LFBB2
 398               	.LM56:
 399 00e6 0130      		cpi r16,lo8(1)
 400 00e8 01F4      		brne .L33
 401               	.L60:
 213:main.c        ****             uart_tx('>');
 402               		.stabn	68,0,213,.LM57-.LFBB2
 403               	.LM57:
 404 00ea 8EE3      		ldi r24,lo8(62)
 405 00ec 0E94 0000 		call uart_tx
 214:main.c        ****             report_buf.button_mask = _BV(7);
 406               		.stabn	68,0,214,.LM58-.LFBB2
 407               	.LM58:
 408 00f0 F092 0000 		sts report_buf,r15
 215:main.c        ****             usbSetInterrupt((void *)&report_buf, sizeof(report_buf));
 409               		.stabn	68,0,215,.LM59-.LFBB2
 410               	.LM59:
 411 00f4 64E0      		ldi r22,lo8(4)
 412 00f6 80E0      		ldi r24,lo8(report_buf)
 413 00f8 90E0      		ldi r25,hi8(report_buf)
 414 00fa 0E94 0000 		call usbSetInterrupt
 415 00fe 00C0      		rjmp .L57
 416               	.L20:
 142:main.c        ****         } else if ( samples[2] > SAMPLE_THRESH && 
 417               		.stabn	68,0,142,.LM60-.LFBB2
 418               	.LM60:
 419 0100 2131      		cpi r18,lo8(17)
 420 0102 00F0      		brlo .L41
 142:main.c        ****         } else if ( samples[2] > SAMPLE_THRESH && 
 421               		.stabn	68,0,142,.LM61-.LFBB2
 422               	.LM61:
 423 0104 8217      		cp r24,r18
 424 0106 00F4      		brsh .L41
 143:main.c        ****                 samples[2] > samples[0] && 
 425               		.stabn	68,0,143,.LM62-.LFBB2
 426               	.LM62:
GAS LISTING /tmp/cc5XZRJy.s 			page 16


 427 0108 9217      		cp r25,r18
 428 010a 00F4      		brsh .L41
 145:main.c        ****             curr = green;
 429               		.stabn	68,0,145,.LM63-.LFBB2
 430               	.LM63:
 431 010c 82E0      		ldi r24,lo8(2)
 432 010e 00C0      		rjmp .L19
 433               	.L41:
 147:main.c        ****             curr = none;
 434               		.stabn	68,0,147,.LM64-.LFBB2
 435               	.LM64:
 436 0110 80E0      		ldi r24,0
 437 0112 00C0      		rjmp .L19
 438               	.L59:
 157:main.c        ****                 switch (curr) {
 439               		.stabn	68,0,157,.LM65-.LFBB2
 440               	.LM65:
 441 0114 8230      		cpi r24,lo8(2)
 442 0116 01F0      		breq .L42
 443 0118 8330      		cpi r24,lo8(3)
 444 011a 01F4      		brne .L56
 445               	.L30:
 196:main.c        ****                         axn = cw;
 446               		.stabn	68,0,196,.LM66-.LFBB2
 447               	.LM66:
 448 011c 01E0      		ldi r16,lo8(1)
 449 011e 00C0      		rjmp .L46
 450               	.L24:
 174:main.c        ****                 switch (curr) {
 451               		.stabn	68,0,174,.LM67-.LFBB2
 452               	.LM67:
 453 0120 8130      		cpi r24,lo8(1)
 454 0122 01F0      		breq .L42
 455 0124 8230      		cpi r24,lo8(2)
 456 0126 01F0      		breq .L30
 193:main.c        ****                         axn = idle;
 457               		.stabn	68,0,193,.LM68-.LFBB2
 458               	.LM68:
 459 0128 00E0      		ldi r16,0
 460 012a 00C0      		rjmp .L36
 461               	.L42:
 168:main.c        ****                         axn = ccw;
 462               		.stabn	68,0,168,.LM69-.LFBB2
 463               	.LM69:
 464 012c 02E0      		ldi r16,lo8(2)
 465 012e 00C0      		rjmp .L46
 466               	.L61:
 217:main.c        ****             uart_tx('<');
 467               		.stabn	68,0,217,.LM70-.LFBB2
 468               	.LM70:
 469 0130 8CE3      		ldi r24,lo8(60)
 470 0132 0E94 0000 		call uart_tx
 218:main.c        ****             report_buf.button_mask = _BV(6);
 471               		.stabn	68,0,218,.LM71-.LFBB2
 472               	.LM71:
 473 0136 E092 0000 		sts report_buf,r14
 219:main.c        ****             usbSetInterrupt((void *)&report_buf, sizeof(report_buf));
GAS LISTING /tmp/cc5XZRJy.s 			page 17


 474               		.stabn	68,0,219,.LM72-.LFBB2
 475               	.LM72:
 476 013a 64E0      		ldi r22,lo8(4)
 477 013c 80E0      		ldi r24,lo8(report_buf)
 478 013e 90E0      		ldi r25,hi8(report_buf)
 479 0140 0E94 0000 		call usbSetInterrupt
 480 0144 00C0      		rjmp .L57
 481               		.size	main, .-main
 482               		.stabs	"i:r(7,2)",64,0,88,25
 483               		.stabs	"samples:(0,19)=ar(11,4);0;2;(7,2)",128,0,89,1
 484               		.stabs	"last:r(1,1)",64,0,90,17
 485               		.stabs	"curr:r(1,1)",64,0,90,24
 486               		.stabs	"axn:r(1,2)",64,0,91,16
 487               		.stabn	192,0,0,.LFBB2-.LFBB2
 488               		.stabn	224,0,0,.Lscope2-.LFBB2
 489               	.Lscope2:
 490               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 491               		.stabd	78,0,0
 492               	.global	usbDescriptorHidReport
 493               		.section	.progmem.data,"a",@progbits
 494               		.type	usbDescriptorHidReport, @object
 495               		.size	usbDescriptorHidReport, 52
 496               	usbDescriptorHidReport:
 497 0000 05        		.byte	5
 498 0001 01        		.byte	1
 499 0002 09        		.byte	9
 500 0003 02        		.byte	2
 501 0004 A1        		.byte	-95
 502 0005 01        		.byte	1
 503 0006 09        		.byte	9
 504 0007 01        		.byte	1
 505 0008 A1        		.byte	-95
 506 0009 00        		.byte	0
 507 000a 05        		.byte	5
 508 000b 09        		.byte	9
 509 000c 19        		.byte	25
 510 000d 01        		.byte	1
 511 000e 29        		.byte	41
 512 000f 03        		.byte	3
 513 0010 15        		.byte	21
 514 0011 00        		.byte	0
 515 0012 25        		.byte	37
 516 0013 01        		.byte	1
 517 0014 95        		.byte	-107
 518 0015 03        		.byte	3
 519 0016 75        		.byte	117
 520 0017 01        		.byte	1
 521 0018 81        		.byte	-127
 522 0019 02        		.byte	2
 523 001a 95        		.byte	-107
 524 001b 01        		.byte	1
 525 001c 75        		.byte	117
 526 001d 05        		.byte	5
 527 001e 81        		.byte	-127
 528 001f 03        		.byte	3
 529 0020 05        		.byte	5
 530 0021 01        		.byte	1
GAS LISTING /tmp/cc5XZRJy.s 			page 18


 531 0022 09        		.byte	9
 532 0023 30        		.byte	48
 533 0024 09        		.byte	9
 534 0025 31        		.byte	49
 535 0026 09        		.byte	9
 536 0027 38        		.byte	56
 537 0028 15        		.byte	21
 538 0029 81        		.byte	-127
 539 002a 25        		.byte	37
 540 002b 7F        		.byte	127
 541 002c 75        		.byte	117
 542 002d 08        		.byte	8
 543 002e 95        		.byte	-107
 544 002f 03        		.byte	3
 545 0030 81        		.byte	-127
 546 0031 06        		.byte	6
 547 0032 C0        		.byte	-64
 548 0033 C0        		.byte	-64
 549               		.local	report_buf
 550               		.comm	report_buf,4,1
 551               		.local	idleRate
 552               		.comm	idleRate,1,1
 553               		.stabs	"report_buf:S(0,16)",40,0,59,report_buf
 554               		.stabs	"idleRate:S(0,11)",40,0,60,idleRate
 555               		.stabs	"usbDescriptorHidReport:G(0,20)=ar(11,4);0;51;(0,21)=k(0,2)",32,0,15,0
 556               		.text
 557               		.stabs	"",100,0,0,.Letext0
 558               	.Letext0:
 559               		.ident	"GCC: (GNU) 4.7.1"
 560               	.global __do_clear_bss
GAS LISTING /tmp/cc5XZRJy.s 			page 19


DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cc5XZRJy.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc5XZRJy.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc5XZRJy.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc5XZRJy.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc5XZRJy.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc5XZRJy.s:94     .text:0000000000000000 usbFunctionSetup
     /tmp/cc5XZRJy.s:550    .bss:0000000000000004 idleRate
                             .bss:0000000000000000 report_buf
     /tmp/cc5XZRJy.s:170    .text.startup:0000000000000000 main
     /tmp/cc5XZRJy.s:496    .progmem.data:0000000000000000 usbDescriptorHidReport

UNDEFINED SYMBOLS
usbMsgPtr
usbInit
uart_init
uart_tx
usbSetInterrupt
__do_clear_bss
