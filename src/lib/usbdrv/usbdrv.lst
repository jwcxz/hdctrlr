GAS LISTING /tmp/ccTUJtEn.s 			page 1


   1               		.file	"usbdrv.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.stabs	"/home/j/projects/hdctrl/src/usbmouse/",100,0,2,.Ltext0
   8               		.stabs	"../lib/usbdrv/usbdrv.c",100,0,2,.Ltext0
   9               		.text
  10               	.Ltext0:
  11               		.stabs	"gcc2_compiled.",60,0,0,0
  12               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,0,0
  13               		.stabs	"char:t(0,2)=@s8;r(0,2);0;255;",128,0,0,0
  14               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,0,0
  15               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,0,0
  16               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,0,0
  17               		.stabs	"long long int:t(0,6)=@s64;r(0,6);01000000000000000000000;0777777777777777777777;",128,0,0,
  18               		.stabs	"long long unsigned int:t(0,7)=@s64;r(0,7);0;01777777777777777777777;",128,0,0,0
  19               		.stabs	"short int:t(0,8)=r(0,8);-32768;32767;",128,0,0,0
  20               		.stabs	"short unsigned int:t(0,9)=r(0,9);0;0177777;",128,0,0,0
  21               		.stabs	"signed char:t(0,10)=@s8;r(0,10);-128;127;",128,0,0,0
  22               		.stabs	"unsigned char:t(0,11)=@s8;r(0,11);0;255;",128,0,0,0
  23               		.stabs	"float:t(0,12)=r(0,1);4;0;",128,0,0,0
  24               		.stabs	"double:t(0,13)=r(0,1);4;0;",128,0,0,0
  25               		.stabs	"long double:t(0,14)=r(0,1);4;0;",128,0,0,0
  26               		.stabs	"void:t(0,15)=(0,15)",128,0,0,0
  27               		.stabs	"../lib/usbdrv/usbportability.h",130,0,0,0
  28               		.stabs	"/usr/lib/gcc/avr/4.7.1/../../../../avr/include/avr/io.h",130,0,0,0
  29               		.stabs	"/usr/lib/gcc/avr/4.7.1/../../../../avr/include/avr/sfr_defs.h",130,0,0,0
  30               		.stabs	"/usr/lib/gcc/avr/4.7.1/../../../../avr/include/inttypes.h",130,0,0,0
  31               		.stabs	"/usr/lib/gcc/avr/4.7.1/include/stdint.h",130,0,0,0
  32               		.stabs	"/usr/lib/gcc/avr/4.7.1/../../../../avr/include/stdint.h",130,0,0,0
  33               		.stabs	"int8_t:t(6,1)=(0,10)",128,0,121,0
  34               		.stabs	"uint8_t:t(6,2)=(0,11)",128,0,122,0
  35               		.stabs	"int16_t:t(6,3)=(0,1)",128,0,123,0
  36               		.stabs	"uint16_t:t(6,4)=(0,4)",128,0,124,0
  37               		.stabs	"int32_t:t(6,5)=(0,3)",128,0,125,0
  38               		.stabs	"uint32_t:t(6,6)=(0,5)",128,0,126,0
  39               		.stabs	"int64_t:t(6,7)=(0,6)",128,0,128,0
  40               		.stabs	"uint64_t:t(6,8)=(0,7)",128,0,129,0
  41               		.stabs	"intptr_t:t(6,9)=(6,3)",128,0,142,0
  42               		.stabs	"uintptr_t:t(6,10)=(6,4)",128,0,147,0
  43               		.stabs	"int_least8_t:t(6,11)=(6,1)",128,0,159,0
  44               		.stabs	"uint_least8_t:t(6,12)=(6,2)",128,0,164,0
  45               		.stabs	"int_least16_t:t(6,13)=(6,3)",128,0,169,0
  46               		.stabs	"uint_least16_t:t(6,14)=(6,4)",128,0,174,0
  47               		.stabs	"int_least32_t:t(6,15)=(6,5)",128,0,179,0
  48               		.stabs	"uint_least32_t:t(6,16)=(6,6)",128,0,184,0
  49               		.stabs	"int_least64_t:t(6,17)=(6,7)",128,0,192,0
  50               		.stabs	"uint_least64_t:t(6,18)=(6,8)",128,0,199,0
  51               		.stabs	"int_fast8_t:t(6,19)=(6,1)",128,0,213,0
  52               		.stabs	"uint_fast8_t:t(6,20)=(6,2)",128,0,218,0
  53               		.stabs	"int_fast16_t:t(6,21)=(6,3)",128,0,223,0
  54               		.stabs	"uint_fast16_t:t(6,22)=(6,4)",128,0,228,0
  55               		.stabs	"int_fast32_t:t(6,23)=(6,5)",128,0,233,0
  56               		.stabs	"uint_fast32_t:t(6,24)=(6,6)",128,0,238,0
  57               		.stabs	"int_fast64_t:t(6,25)=(6,7)",128,0,246,0
GAS LISTING /tmp/ccTUJtEn.s 			page 2


  58               		.stabs	"uint_fast64_t:t(6,26)=(6,8)",128,0,253,0
  59               		.stabs	"intmax_t:t(6,27)=(6,7)",128,0,273,0
  60               		.stabs	"uintmax_t:t(6,28)=(6,8)",128,0,278,0
  61               		.stabn	162,0,0,0
  62               		.stabn	162,0,0,0
  63               		.stabs	"int_farptr_t:t(4,1)=(6,5)",128,0,77,0
  64               		.stabs	"uint_farptr_t:t(4,2)=(6,6)",128,0,81,0
  65               		.stabn	162,0,0,0
  66               		.stabn	162,0,0,0
  67               		.stabs	"/usr/lib/gcc/avr/4.7.1/../../../../avr/include/avr/fuse.h",130,0,0,0
  68               		.stabs	"__fuse_t:t(7,1)=(7,2)=s3low:(0,11),0,8;high:(0,11),8,8;extended:(0,11),16,8;;",128,0,244,0
  69               		.stabn	162,0,0,0
  70               		.stabn	162,0,0,0
  71               		.stabs	"/usr/lib/gcc/avr/4.7.1/../../../../avr/include/avr/pgmspace.h",130,0,0,0
  72               		.stabs	"/usr/lib/gcc/avr/4.7.1/include/stddef.h",130,0,0,0
  73               		.stabs	"size_t:t(9,1)=(0,4)",128,0,213,0
  74               		.stabn	162,0,0,0
  75               		.stabn	162,0,0,0
  76               		.stabn	162,0,0,0
  77               		.stabs	"../lib/usbdrv/usbdrv.h",130,0,0,0
  78               		.stabs	"usbTxStatus:T(10,1)=s12len:(10,2)=B(0,11),0,8;buffer:(10,3)=ar(10,4)=r(10,4);0;0177777;;0;
  79               		.stabs	"usbTxStatus_t:t(10,5)=(10,1)",128,0,650,0
  80               		.stabs	"usbWord:T(10,6)=u2word:(0,4),0,16;bytes:(10,7)=ar(10,4);0;1;(0,11),0,16;;",128,0,0,0
  81               		.stabs	"usbWord_t:t(10,8)=(10,6)",128,0,662,0
  82               		.stabs	"usbRequest:T(10,9)=s8bmRequestType:(0,11),0,8;bRequest:(0,11),8,8;wValue:(10,8),16,16;wInd
  83               		.stabs	"usbRequest_t:t(10,10)=(10,9)",128,0,670,0
  84               		.stabn	162,0,0,0
  85               		.stabs	"usbSetInterrupt:F(0,15)",36,0,245,usbSetInterrupt
  86               		.stabs	"len:P(0,11)",64,0,245,28
  87               	.global	usbSetInterrupt
  88               		.type	usbSetInterrupt, @function
  89               	usbSetInterrupt:
  90               		.stabd	46,0,0
   1:../lib/usbdrv/usbdrv.c **** /* Name: usbdrv.c
   2:../lib/usbdrv/usbdrv.c ****  * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   3:../lib/usbdrv/usbdrv.c ****  * Author: Christian Starkjohann
   4:../lib/usbdrv/usbdrv.c ****  * Creation Date: 2004-12-29
   5:../lib/usbdrv/usbdrv.c ****  * Tabsize: 4
   6:../lib/usbdrv/usbdrv.c ****  * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
   7:../lib/usbdrv/usbdrv.c ****  * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
   8:../lib/usbdrv/usbdrv.c ****  * This Revision: $Id$
   9:../lib/usbdrv/usbdrv.c ****  */
  10:../lib/usbdrv/usbdrv.c **** 
  11:../lib/usbdrv/usbdrv.c **** #include "usbportability.h"
  12:../lib/usbdrv/usbdrv.c **** #include "usbdrv.h"
  13:../lib/usbdrv/usbdrv.c **** #include "oddebug.h"
  14:../lib/usbdrv/usbdrv.c **** 
  15:../lib/usbdrv/usbdrv.c **** /*
  16:../lib/usbdrv/usbdrv.c **** General Description:
  17:../lib/usbdrv/usbdrv.c **** This module implements the C-part of the USB driver. See usbdrv.h for a
  18:../lib/usbdrv/usbdrv.c **** documentation of the entire driver.
  19:../lib/usbdrv/usbdrv.c **** */
  20:../lib/usbdrv/usbdrv.c **** 
  21:../lib/usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
  22:../lib/usbdrv/usbdrv.c **** 
  23:../lib/usbdrv/usbdrv.c **** /* raw USB registers / interface to assembler code: */
  24:../lib/usbdrv/usbdrv.c **** uchar usbRxBuf[2*USB_BUFSIZE];  /* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */
GAS LISTING /tmp/ccTUJtEn.s 			page 3


  25:../lib/usbdrv/usbdrv.c **** uchar       usbInputBufOffset;  /* offset in usbRxBuf used for low level receiving */
  26:../lib/usbdrv/usbdrv.c **** uchar       usbDeviceAddr;      /* assigned during enumeration, defaults to 0 */
  27:../lib/usbdrv/usbdrv.c **** uchar       usbNewDeviceAddr;   /* device ID which should be set after status phase */
  28:../lib/usbdrv/usbdrv.c **** uchar       usbConfiguration;   /* currently selected configuration. Administered by driver, but no
  29:../lib/usbdrv/usbdrv.c **** volatile schar usbRxLen;        /* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow cont
  30:../lib/usbdrv/usbdrv.c **** uchar       usbCurrentTok;      /* last token received or endpoint number for last OUT token if != 
  31:../lib/usbdrv/usbdrv.c **** uchar       usbRxToken;         /* token for data we received; or endpont number for last OUT */
  32:../lib/usbdrv/usbdrv.c **** volatile uchar usbTxLen = USBPID_NAK;   /* number of bytes to transmit with next IN token or handsh
  33:../lib/usbdrv/usbdrv.c **** uchar       usbTxBuf[USB_BUFSIZE];/* data to transmit with next IN, free if usbTxLen contains hands
  34:../lib/usbdrv/usbdrv.c **** #if USB_COUNT_SOF
  35:../lib/usbdrv/usbdrv.c **** volatile uchar  usbSofCount;    /* incremented by assembler module every SOF */
  36:../lib/usbdrv/usbdrv.c **** #endif
  37:../lib/usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
  38:../lib/usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus1;
  39:../lib/usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
  40:../lib/usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus3;
  41:../lib/usbdrv/usbdrv.c **** #   endif
  42:../lib/usbdrv/usbdrv.c **** #endif
  43:../lib/usbdrv/usbdrv.c **** #if USB_CFG_CHECK_DATA_TOGGLING
  44:../lib/usbdrv/usbdrv.c **** uchar       usbCurrentDataToken;/* when we check data toggling to ignore duplicate packets */
  45:../lib/usbdrv/usbdrv.c **** #endif
  46:../lib/usbdrv/usbdrv.c **** 
  47:../lib/usbdrv/usbdrv.c **** /* USB status registers / not shared with asm code */
  48:../lib/usbdrv/usbdrv.c **** uchar               *usbMsgPtr;     /* data to transmit next -- ROM or RAM address */
  49:../lib/usbdrv/usbdrv.c **** static usbMsgLen_t  usbMsgLen = USB_NO_MSG; /* remaining number of bytes */
  50:../lib/usbdrv/usbdrv.c **** static uchar        usbMsgFlags;    /* flag values see below */
  51:../lib/usbdrv/usbdrv.c **** 
  52:../lib/usbdrv/usbdrv.c **** #define USB_FLG_MSGPTR_IS_ROM   (1<<6)
  53:../lib/usbdrv/usbdrv.c **** #define USB_FLG_USE_USER_RW     (1<<7)
  54:../lib/usbdrv/usbdrv.c **** 
  55:../lib/usbdrv/usbdrv.c **** /*
  56:../lib/usbdrv/usbdrv.c **** optimizing hints:
  57:../lib/usbdrv/usbdrv.c **** - do not post/pre inc/dec integer values in operations
  58:../lib/usbdrv/usbdrv.c **** - assign value of USB_READ_FLASH() to register variables and don't use side effects in arg
  59:../lib/usbdrv/usbdrv.c **** - use narrow scope for variables which should be in X/Y/Z register
  60:../lib/usbdrv/usbdrv.c **** - assign char sized expressions to variables to force 8 bit arithmetics
  61:../lib/usbdrv/usbdrv.c **** */
  62:../lib/usbdrv/usbdrv.c **** 
  63:../lib/usbdrv/usbdrv.c **** /* -------------------------- String Descriptors --------------------------- */
  64:../lib/usbdrv/usbdrv.c **** 
  65:../lib/usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS == 0
  66:../lib/usbdrv/usbdrv.c **** 
  67:../lib/usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_0 == 0
  68:../lib/usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_0
  69:../lib/usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)
  70:../lib/usbdrv/usbdrv.c **** const PROGMEM char usbDescriptorString0[] = { /* language descriptor */
  71:../lib/usbdrv/usbdrv.c ****     4,          /* sizeof(usbDescriptorString0): length of descriptor in bytes */
  72:../lib/usbdrv/usbdrv.c ****     3,          /* descriptor type */
  73:../lib/usbdrv/usbdrv.c ****     0x09, 0x04, /* language index (0x0409 = US-English) */
  74:../lib/usbdrv/usbdrv.c **** };
  75:../lib/usbdrv/usbdrv.c **** #endif
  76:../lib/usbdrv/usbdrv.c **** 
  77:../lib/usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 && USB_CFG_VENDOR_NAME_LEN
  78:../lib/usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_VENDOR
  79:../lib/usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)
  80:../lib/usbdrv/usbdrv.c **** const PROGMEM int  usbDescriptorStringVendor[] = {
  81:../lib/usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_VENDOR_NAME_LEN),
GAS LISTING /tmp/ccTUJtEn.s 			page 4


  82:../lib/usbdrv/usbdrv.c ****     USB_CFG_VENDOR_NAME
  83:../lib/usbdrv/usbdrv.c **** };
  84:../lib/usbdrv/usbdrv.c **** #endif
  85:../lib/usbdrv/usbdrv.c **** 
  86:../lib/usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 && USB_CFG_DEVICE_NAME_LEN
  87:../lib/usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_PRODUCT
  88:../lib/usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)
  89:../lib/usbdrv/usbdrv.c **** const PROGMEM int  usbDescriptorStringDevice[] = {
  90:../lib/usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_DEVICE_NAME_LEN),
  91:../lib/usbdrv/usbdrv.c ****     USB_CFG_DEVICE_NAME
  92:../lib/usbdrv/usbdrv.c **** };
  93:../lib/usbdrv/usbdrv.c **** #endif
  94:../lib/usbdrv/usbdrv.c **** 
  95:../lib/usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 && USB_CFG_SERIAL_NUMBER_LEN
  96:../lib/usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
  97:../lib/usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)
  98:../lib/usbdrv/usbdrv.c **** const PROGMEM int usbDescriptorStringSerialNumber[] = {
  99:../lib/usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_SERIAL_NUMBER_LEN),
 100:../lib/usbdrv/usbdrv.c ****     USB_CFG_SERIAL_NUMBER
 101:../lib/usbdrv/usbdrv.c **** };
 102:../lib/usbdrv/usbdrv.c **** #endif
 103:../lib/usbdrv/usbdrv.c **** 
 104:../lib/usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS == 0 */
 105:../lib/usbdrv/usbdrv.c **** 
 106:../lib/usbdrv/usbdrv.c **** /* --------------------------- Device Descriptor --------------------------- */
 107:../lib/usbdrv/usbdrv.c **** 
 108:../lib/usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_DEVICE == 0
 109:../lib/usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_DEVICE
 110:../lib/usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)
 111:../lib/usbdrv/usbdrv.c **** const PROGMEM char usbDescriptorDevice[] = {    /* USB device descriptor */
 112:../lib/usbdrv/usbdrv.c ****     18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
 113:../lib/usbdrv/usbdrv.c ****     USBDESCR_DEVICE,        /* descriptor type */
 114:../lib/usbdrv/usbdrv.c ****     0x10, 0x01,             /* USB version supported */
 115:../lib/usbdrv/usbdrv.c ****     USB_CFG_DEVICE_CLASS,
 116:../lib/usbdrv/usbdrv.c ****     USB_CFG_DEVICE_SUBCLASS,
 117:../lib/usbdrv/usbdrv.c ****     0,                      /* protocol */
 118:../lib/usbdrv/usbdrv.c ****     8,                      /* max packet size */
 119:../lib/usbdrv/usbdrv.c ****     /* the following two casts affect the first byte of the constant only, but
 120:../lib/usbdrv/usbdrv.c ****      * that's sufficient to avoid a warning with the default values.
 121:../lib/usbdrv/usbdrv.c ****      */
 122:../lib/usbdrv/usbdrv.c ****     (char)USB_CFG_VENDOR_ID,/* 2 bytes */
 123:../lib/usbdrv/usbdrv.c ****     (char)USB_CFG_DEVICE_ID,/* 2 bytes */
 124:../lib/usbdrv/usbdrv.c ****     USB_CFG_DEVICE_VERSION, /* 2 bytes */
 125:../lib/usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
 126:../lib/usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
 127:../lib/usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
 128:../lib/usbdrv/usbdrv.c ****     1,          /* number of configurations */
 129:../lib/usbdrv/usbdrv.c **** };
 130:../lib/usbdrv/usbdrv.c **** #endif
 131:../lib/usbdrv/usbdrv.c **** 
 132:../lib/usbdrv/usbdrv.c **** /* ----------------------- Configuration Descriptor ------------------------ */
 133:../lib/usbdrv/usbdrv.c **** 
 134:../lib/usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT != 0 && USB_CFG_DESCR_PROPS_HID == 0
 135:../lib/usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_HID
 136:../lib/usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_HID     9   /* length of HID descriptor in config descriptor below */
 137:../lib/usbdrv/usbdrv.c **** #endif
 138:../lib/usbdrv/usbdrv.c **** 
GAS LISTING /tmp/ccTUJtEn.s 			page 5


 139:../lib/usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_CONFIGURATION == 0
 140:../lib/usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_CONFIGURATION
 141:../lib/usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)
 142:../lib/usbdrv/usbdrv.c **** const PROGMEM char usbDescriptorConfiguration[] = {    /* USB configuration descriptor */
 143:../lib/usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
 144:../lib/usbdrv/usbdrv.c ****     USBDESCR_CONFIG,    /* descriptor type */
 145:../lib/usbdrv/usbdrv.c ****     18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT3 +
 146:../lib/usbdrv/usbdrv.c ****                 (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
 147:../lib/usbdrv/usbdrv.c ****                 /* total length of data returned (including inlined descriptors) */
 148:../lib/usbdrv/usbdrv.c ****     1,          /* number of interfaces in this configuration */
 149:../lib/usbdrv/usbdrv.c ****     1,          /* index of this configuration */
 150:../lib/usbdrv/usbdrv.c ****     0,          /* configuration name string index */
 151:../lib/usbdrv/usbdrv.c **** #if USB_CFG_IS_SELF_POWERED
 152:../lib/usbdrv/usbdrv.c ****     (1 << 7) | USBATTR_SELFPOWER,       /* attributes */
 153:../lib/usbdrv/usbdrv.c **** #else
 154:../lib/usbdrv/usbdrv.c ****     (1 << 7),                           /* attributes */
 155:../lib/usbdrv/usbdrv.c **** #endif
 156:../lib/usbdrv/usbdrv.c ****     USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
 157:../lib/usbdrv/usbdrv.c **** /* interface descriptor follows inline: */
 158:../lib/usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
 159:../lib/usbdrv/usbdrv.c ****     USBDESCR_INTERFACE, /* descriptor type */
 160:../lib/usbdrv/usbdrv.c ****     0,          /* index of this interface */
 161:../lib/usbdrv/usbdrv.c ****     0,          /* alternate setting for this interface */
 162:../lib/usbdrv/usbdrv.c ****     USB_CFG_HAVE_INTRIN_ENDPOINT + USB_CFG_HAVE_INTRIN_ENDPOINT3, /* endpoints excl 0: number of en
 163:../lib/usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_CLASS,
 164:../lib/usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_SUBCLASS,
 165:../lib/usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_PROTOCOL,
 166:../lib/usbdrv/usbdrv.c ****     0,          /* string index for interface */
 167:../lib/usbdrv/usbdrv.c **** #if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
 168:../lib/usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
 169:../lib/usbdrv/usbdrv.c ****     USBDESCR_HID,   /* descriptor type: HID */
 170:../lib/usbdrv/usbdrv.c ****     0x01, 0x01, /* BCD representation of HID version */
 171:../lib/usbdrv/usbdrv.c ****     0x00,       /* target country code */
 172:../lib/usbdrv/usbdrv.c ****     0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
 173:../lib/usbdrv/usbdrv.c ****     0x22,       /* descriptor type: report */
 174:../lib/usbdrv/usbdrv.c ****     USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
 175:../lib/usbdrv/usbdrv.c **** #endif
 176:../lib/usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
 177:../lib/usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 178:../lib/usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 179:../lib/usbdrv/usbdrv.c ****     (char)0x81, /* IN endpoint number 1 */
 180:../lib/usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 181:../lib/usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 182:../lib/usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 183:../lib/usbdrv/usbdrv.c **** #endif
 184:../lib/usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3   /* endpoint descriptor for endpoint 3 */
 185:../lib/usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 186:../lib/usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 187:../lib/usbdrv/usbdrv.c ****     (char)(0x80 | USB_CFG_EP3_NUMBER), /* IN endpoint number 3 */
 188:../lib/usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 189:../lib/usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 190:../lib/usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 191:../lib/usbdrv/usbdrv.c **** #endif
 192:../lib/usbdrv/usbdrv.c **** };
 193:../lib/usbdrv/usbdrv.c **** #endif
 194:../lib/usbdrv/usbdrv.c **** 
 195:../lib/usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
GAS LISTING /tmp/ccTUJtEn.s 			page 6


 196:../lib/usbdrv/usbdrv.c **** 
 197:../lib/usbdrv/usbdrv.c **** static inline void  usbResetDataToggling(void)
 198:../lib/usbdrv/usbdrv.c **** {
 199:../lib/usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 200:../lib/usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 201:../lib/usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
 202:../lib/usbdrv/usbdrv.c ****     USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 203:../lib/usbdrv/usbdrv.c **** #   endif
 204:../lib/usbdrv/usbdrv.c **** #endif
 205:../lib/usbdrv/usbdrv.c **** }
 206:../lib/usbdrv/usbdrv.c **** 
 207:../lib/usbdrv/usbdrv.c **** static inline void  usbResetStall(void)
 208:../lib/usbdrv/usbdrv.c **** {
 209:../lib/usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
 210:../lib/usbdrv/usbdrv.c ****         usbTxLen1 = USBPID_NAK;
 211:../lib/usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 212:../lib/usbdrv/usbdrv.c ****         usbTxLen3 = USBPID_NAK;
 213:../lib/usbdrv/usbdrv.c **** #endif
 214:../lib/usbdrv/usbdrv.c **** #endif
 215:../lib/usbdrv/usbdrv.c **** }
 216:../lib/usbdrv/usbdrv.c **** 
 217:../lib/usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 218:../lib/usbdrv/usbdrv.c **** 
 219:../lib/usbdrv/usbdrv.c **** #if !USB_CFG_SUPPRESS_INTR_CODE
 220:../lib/usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT
 221:../lib/usbdrv/usbdrv.c **** static void usbGenericSetInterrupt(uchar *data, uchar len, usbTxStatus_t *txStatus)
 222:../lib/usbdrv/usbdrv.c **** {
 223:../lib/usbdrv/usbdrv.c **** uchar   *p;
 224:../lib/usbdrv/usbdrv.c **** char    i;
 225:../lib/usbdrv/usbdrv.c **** 
 226:../lib/usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 227:../lib/usbdrv/usbdrv.c ****     if(usbTxLen1 == USBPID_STALL)
 228:../lib/usbdrv/usbdrv.c ****         return;
 229:../lib/usbdrv/usbdrv.c **** #endif
 230:../lib/usbdrv/usbdrv.c ****     if(txStatus->len & 0x10){   /* packet buffer was empty */
 231:../lib/usbdrv/usbdrv.c ****         txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
 232:../lib/usbdrv/usbdrv.c ****     }else{
 233:../lib/usbdrv/usbdrv.c ****         txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
 234:../lib/usbdrv/usbdrv.c ****     }
 235:../lib/usbdrv/usbdrv.c ****     p = txStatus->buffer + 1;
 236:../lib/usbdrv/usbdrv.c ****     i = len;
 237:../lib/usbdrv/usbdrv.c ****     do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
 238:../lib/usbdrv/usbdrv.c ****         *p++ = *data++;
 239:../lib/usbdrv/usbdrv.c ****     }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
 240:../lib/usbdrv/usbdrv.c ****     usbCrc16Append(&txStatus->buffer[1], len);
 241:../lib/usbdrv/usbdrv.c ****     txStatus->len = len + 4;    /* len must be given including sync byte */
 242:../lib/usbdrv/usbdrv.c ****     DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
 243:../lib/usbdrv/usbdrv.c **** }
 244:../lib/usbdrv/usbdrv.c **** 
 245:../lib/usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
 246:../lib/usbdrv/usbdrv.c **** {
  91               		.stabn	68,0,246,.LM0-.LFBB1
  92               	.LM0:
  93               	.LFBB1:
  94 0000 CF93      		push r28
  95               	/* prologue: function */
  96               	/* frame size = 0 */
GAS LISTING /tmp/ccTUJtEn.s 			page 7


  97               	/* stack size = 1 */
  98               	.L__stack_usage = 1
  99 0002 C62F      		mov r28,r22
 100               	.LBB24:
 101               	.LBB25:
 230:../lib/usbdrv/usbdrv.c ****     if(txStatus->len & 0x10){   /* packet buffer was empty */
 102               		.stabn	68,0,230,.LM1-.LFBB1
 103               	.LM1:
 104 0004 2091 0000 		lds r18,usbTxStatus1
 105 0008 24FF      		sbrs r18,4
 106 000a 00C0      		rjmp .L2
 231:../lib/usbdrv/usbdrv.c ****         txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
 107               		.stabn	68,0,231,.LM2-.LFBB1
 108               	.LM2:
 109 000c 2091 0000 		lds r18,usbTxStatus1+1
 110 0010 38E8      		ldi r19,lo8(-120)
 111 0012 2327      		eor r18,r19
 112 0014 2093 0000 		sts usbTxStatus1+1,r18
 113               	.L3:
 114 0018 FC01      		movw r30,r24
 115               	.LBE25:
 116               	.LBE24:
 117               		.stabn	68,0,246,.LM3-.LFBB1
 118               	.LM3:
 119 001a 8C2F      		mov r24,r28
 120 001c A0E0      		ldi r26,lo8(usbTxStatus1+2)
 121 001e B0E0      		ldi r27,hi8(usbTxStatus1+2)
 122               	.L4:
 123               	.LBB28:
 124               	.LBB26:
 238:../lib/usbdrv/usbdrv.c ****         *p++ = *data++;
 125               		.stabn	68,0,238,.LM4-.LFBB1
 126               	.LM4:
 127 0020 9191      		ld r25,Z+
 128 0022 9D93      		st X+,r25
 239:../lib/usbdrv/usbdrv.c ****     }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
 129               		.stabn	68,0,239,.LM5-.LFBB1
 130               	.LM5:
 131 0024 8150      		subi r24,lo8(-(-1))
 132 0026 01F4      		brne .L4
 240:../lib/usbdrv/usbdrv.c ****     usbCrc16Append(&txStatus->buffer[1], len);
 133               		.stabn	68,0,240,.LM6-.LFBB1
 134               	.LM6:
 135 0028 6C2F      		mov r22,r28
 136 002a 80E0      		ldi r24,lo8(usbTxStatus1+2)
 137 002c 90E0      		ldi r25,hi8(usbTxStatus1+2)
 138 002e 0E94 0000 		call usbCrc16Append
 241:../lib/usbdrv/usbdrv.c ****     txStatus->len = len + 4;    /* len must be given including sync byte */
 139               		.stabn	68,0,241,.LM7-.LFBB1
 140               	.LM7:
 141 0032 CC5F      		subi r28,lo8(-(4))
 142 0034 C093 0000 		sts usbTxStatus1,r28
 143               	/* epilogue start */
 144               	.LBE26:
 145               	.LBE28:
 247:../lib/usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus1);
 248:../lib/usbdrv/usbdrv.c **** }
GAS LISTING /tmp/ccTUJtEn.s 			page 8


 146               		.stabn	68,0,248,.LM8-.LFBB1
 147               	.LM8:
 148 0038 CF91      		pop r28
 149 003a 0895      		ret
 150               	.L2:
 151               	.LBB29:
 152               	.LBB27:
 233:../lib/usbdrv/usbdrv.c ****         txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
 153               		.stabn	68,0,233,.LM9-.LFBB1
 154               	.LM9:
 155 003c 2AE5      		ldi r18,lo8(90)
 156 003e 2093 0000 		sts usbTxStatus1,r18
 157 0042 00C0      		rjmp .L3
 158               	.LBE27:
 159               	.LBE29:
 160               		.size	usbSetInterrupt, .-usbSetInterrupt
 161               		.stabs	"p:r(0,16)=*(0,11)",64,0,223,26
 162               		.stabn	192,0,0,.LBB25-.LFBB1
 163               		.stabn	224,0,0,.LBE25-.LFBB1
 164               		.stabs	"p:r(0,16)",64,0,223,26
 165               		.stabn	192,0,0,.LBB26-.LFBB1
 166               		.stabn	224,0,0,.LBE26-.LFBB1
 167               		.stabs	"p:r(0,16)",64,0,223,26
 168               		.stabn	192,0,0,.LBB27-.LFBB1
 169               		.stabn	224,0,0,.LBE27-.LFBB1
 170               	.Lscope1:
 171               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 172               		.stabd	78,0,0
 173               		.stabs	"usbPoll:F(0,15)",36,0,568,usbPoll
 174               	.global	usbPoll
 175               		.type	usbPoll, @function
 176               	usbPoll:
 177               		.stabd	46,0,0
 249:../lib/usbdrv/usbdrv.c **** #endif
 250:../lib/usbdrv/usbdrv.c **** 
 251:../lib/usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 252:../lib/usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
 253:../lib/usbdrv/usbdrv.c **** {
 254:../lib/usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus3);
 255:../lib/usbdrv/usbdrv.c **** }
 256:../lib/usbdrv/usbdrv.c **** #endif
 257:../lib/usbdrv/usbdrv.c **** #endif /* USB_CFG_SUPPRESS_INTR_CODE */
 258:../lib/usbdrv/usbdrv.c **** 
 259:../lib/usbdrv/usbdrv.c **** /* ------------------ utilities for code following below ------------------- */
 260:../lib/usbdrv/usbdrv.c **** 
 261:../lib/usbdrv/usbdrv.c **** /* Use defines for the switch statement so that we can choose between an
 262:../lib/usbdrv/usbdrv.c ****  * if()else if() and a switch/case based implementation. switch() is more
 263:../lib/usbdrv/usbdrv.c ****  * efficient for a LARGE set of sequential choices, if() is better in all other
 264:../lib/usbdrv/usbdrv.c ****  * cases.
 265:../lib/usbdrv/usbdrv.c ****  */
 266:../lib/usbdrv/usbdrv.c **** #if USB_CFG_USE_SWITCH_STATEMENT
 267:../lib/usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       switch(cmd){{
 268:../lib/usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }break; case (value):{
 269:../lib/usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }break; case (v1): case(v2):{
 270:../lib/usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }break; case (v1): case(v2): case(v3):{
 271:../lib/usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }break; default:{
 272:../lib/usbdrv/usbdrv.c **** #   define SWITCH_END              }}
GAS LISTING /tmp/ccTUJtEn.s 			page 9


 273:../lib/usbdrv/usbdrv.c **** #else
 274:../lib/usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       {uchar _cmd = cmd; if(0){
 275:../lib/usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }else if(_cmd == (value)){
 276:../lib/usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }else if(_cmd == (v1) || _cmd == (v2)){
 277:../lib/usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }else if(_cmd == (v1) || _cmd == (v2) || (_cmd == v3)){
 278:../lib/usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }else{
 279:../lib/usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 280:../lib/usbdrv/usbdrv.c **** #endif
 281:../lib/usbdrv/usbdrv.c **** 
 282:../lib/usbdrv/usbdrv.c **** #ifndef USB_RX_USER_HOOK
 283:../lib/usbdrv/usbdrv.c **** #define USB_RX_USER_HOOK(data, len)
 284:../lib/usbdrv/usbdrv.c **** #endif
 285:../lib/usbdrv/usbdrv.c **** #ifndef USB_SET_ADDRESS_HOOK
 286:../lib/usbdrv/usbdrv.c **** #define USB_SET_ADDRESS_HOOK()
 287:../lib/usbdrv/usbdrv.c **** #endif
 288:../lib/usbdrv/usbdrv.c **** 
 289:../lib/usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 290:../lib/usbdrv/usbdrv.c **** 
 291:../lib/usbdrv/usbdrv.c **** /* We use if() instead of #if in the macro below because #if can't be used
 292:../lib/usbdrv/usbdrv.c ****  * in macros and the compiler optimizes constant conditions anyway.
 293:../lib/usbdrv/usbdrv.c ****  * This may cause problems with undefined symbols if compiled without
 294:../lib/usbdrv/usbdrv.c ****  * optimizing!
 295:../lib/usbdrv/usbdrv.c ****  */
 296:../lib/usbdrv/usbdrv.c **** #define GET_DESCRIPTOR(cfgProp, staticName)         \
 297:../lib/usbdrv/usbdrv.c ****     if(cfgProp){                                    \
 298:../lib/usbdrv/usbdrv.c ****         if((cfgProp) & USB_PROP_IS_RAM)             \
 299:../lib/usbdrv/usbdrv.c ****             flags = 0;                              \
 300:../lib/usbdrv/usbdrv.c ****         if((cfgProp) & USB_PROP_IS_DYNAMIC){        \
 301:../lib/usbdrv/usbdrv.c ****             len = usbFunctionDescriptor(rq);        \
 302:../lib/usbdrv/usbdrv.c ****         }else{                                      \
 303:../lib/usbdrv/usbdrv.c ****             len = USB_PROP_LENGTH(cfgProp);         \
 304:../lib/usbdrv/usbdrv.c ****             usbMsgPtr = (uchar *)(staticName);      \
 305:../lib/usbdrv/usbdrv.c ****         }                                           \
 306:../lib/usbdrv/usbdrv.c ****     }
 307:../lib/usbdrv/usbdrv.c **** 
 308:../lib/usbdrv/usbdrv.c **** /* usbDriverDescriptor() is similar to usbFunctionDescriptor(), but used
 309:../lib/usbdrv/usbdrv.c ****  * internally for all types of descriptors.
 310:../lib/usbdrv/usbdrv.c ****  */
 311:../lib/usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
 312:../lib/usbdrv/usbdrv.c **** {
 313:../lib/usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 314:../lib/usbdrv/usbdrv.c **** uchar       flags = USB_FLG_MSGPTR_IS_ROM;
 315:../lib/usbdrv/usbdrv.c **** 
 316:../lib/usbdrv/usbdrv.c ****     SWITCH_START(rq->wValue.bytes[1])
 317:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
 318:../lib/usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 319:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 320:../lib/usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 321:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 322:../lib/usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
 323:../lib/usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
 324:../lib/usbdrv/usbdrv.c ****             flags = 0;
 325:../lib/usbdrv/usbdrv.c ****         len = usbFunctionDescriptor(rq);
 326:../lib/usbdrv/usbdrv.c **** #else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 327:../lib/usbdrv/usbdrv.c ****         SWITCH_START(rq->wValue.bytes[0])
 328:../lib/usbdrv/usbdrv.c ****         SWITCH_CASE(0)
 329:../lib/usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
GAS LISTING /tmp/ccTUJtEn.s 			page 10


 330:../lib/usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 331:../lib/usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
 332:../lib/usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 333:../lib/usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 334:../lib/usbdrv/usbdrv.c ****         SWITCH_CASE(3)
 335:../lib/usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER, usbDescriptorStringSerialNumbe
 336:../lib/usbdrv/usbdrv.c ****         SWITCH_DEFAULT
 337:../lib/usbdrv/usbdrv.c ****             if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 338:../lib/usbdrv/usbdrv.c ****                 len = usbFunctionDescriptor(rq);
 339:../lib/usbdrv/usbdrv.c ****             }
 340:../lib/usbdrv/usbdrv.c ****         SWITCH_END
 341:../lib/usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 342:../lib/usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
 343:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
 344:../lib/usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
 345:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
 346:../lib/usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
 347:../lib/usbdrv/usbdrv.c **** #endif
 348:../lib/usbdrv/usbdrv.c ****     SWITCH_DEFAULT
 349:../lib/usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 350:../lib/usbdrv/usbdrv.c ****             len = usbFunctionDescriptor(rq);
 351:../lib/usbdrv/usbdrv.c ****         }
 352:../lib/usbdrv/usbdrv.c ****     SWITCH_END
 353:../lib/usbdrv/usbdrv.c ****     usbMsgFlags = flags;
 354:../lib/usbdrv/usbdrv.c ****     return len;
 355:../lib/usbdrv/usbdrv.c **** }
 356:../lib/usbdrv/usbdrv.c **** 
 357:../lib/usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 358:../lib/usbdrv/usbdrv.c **** 
 359:../lib/usbdrv/usbdrv.c **** /* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for
 360:../lib/usbdrv/usbdrv.c ****  * standard requests instead of class and custom requests.
 361:../lib/usbdrv/usbdrv.c ****  */
 362:../lib/usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
 363:../lib/usbdrv/usbdrv.c **** {
 364:../lib/usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 365:../lib/usbdrv/usbdrv.c **** uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
 366:../lib/usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 367:../lib/usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 368:../lib/usbdrv/usbdrv.c **** uchar   index = rq->wIndex.bytes[0];
 369:../lib/usbdrv/usbdrv.c **** #endif
 370:../lib/usbdrv/usbdrv.c **** 
 371:../lib/usbdrv/usbdrv.c ****     dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 372:../lib/usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 373:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 374:../lib/usbdrv/usbdrv.c ****         uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to
 375:../lib/usbdrv/usbdrv.c ****         if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
 376:../lib/usbdrv/usbdrv.c ****             dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
 377:../lib/usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 378:../lib/usbdrv/usbdrv.c ****         if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
 379:../lib/usbdrv/usbdrv.c ****             dataPtr[0] = usbTxLen1 == USBPID_STALL;
 380:../lib/usbdrv/usbdrv.c **** #endif
 381:../lib/usbdrv/usbdrv.c ****         dataPtr[1] = 0;
 382:../lib/usbdrv/usbdrv.c ****         len = 2;
 383:../lib/usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 384:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */
 385:../lib/usbdrv/usbdrv.c ****         if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
 386:../lib/usbdrv/usbdrv.c ****             usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
GAS LISTING /tmp/ccTUJtEn.s 			page 11


 387:../lib/usbdrv/usbdrv.c ****             usbResetDataToggling();
 388:../lib/usbdrv/usbdrv.c ****         }
 389:../lib/usbdrv/usbdrv.c **** #endif
 390:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
 391:../lib/usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 392:../lib/usbdrv/usbdrv.c ****         USB_SET_ADDRESS_HOOK();
 393:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
 394:../lib/usbdrv/usbdrv.c ****         len = usbDriverDescriptor(rq);
 395:../lib/usbdrv/usbdrv.c ****         goto skipMsgPtrAssignment;
 396:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
 397:../lib/usbdrv/usbdrv.c ****         dataPtr = &usbConfiguration;  /* send current configuration value */
 398:../lib/usbdrv/usbdrv.c ****         len = 1;
 399:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
 400:../lib/usbdrv/usbdrv.c ****         usbConfiguration = value;
 401:../lib/usbdrv/usbdrv.c ****         usbResetStall();
 402:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
 403:../lib/usbdrv/usbdrv.c ****         len = 1;
 404:../lib/usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 405:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
 406:../lib/usbdrv/usbdrv.c ****         usbResetDataToggling();
 407:../lib/usbdrv/usbdrv.c ****         usbResetStall();
 408:../lib/usbdrv/usbdrv.c **** #endif
 409:../lib/usbdrv/usbdrv.c ****     SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
 410:../lib/usbdrv/usbdrv.c ****         /* Should we add an optional hook here? */
 411:../lib/usbdrv/usbdrv.c ****     SWITCH_END
 412:../lib/usbdrv/usbdrv.c ****     usbMsgPtr = dataPtr;
 413:../lib/usbdrv/usbdrv.c **** skipMsgPtrAssignment:
 414:../lib/usbdrv/usbdrv.c ****     return len;
 415:../lib/usbdrv/usbdrv.c **** }
 416:../lib/usbdrv/usbdrv.c **** 
 417:../lib/usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 418:../lib/usbdrv/usbdrv.c **** 
 419:../lib/usbdrv/usbdrv.c **** /* usbProcessRx() is called for every message received by the interrupt
 420:../lib/usbdrv/usbdrv.c ****  * routine. It distinguishes between SETUP and DATA packets and processes
 421:../lib/usbdrv/usbdrv.c ****  * them accordingly.
 422:../lib/usbdrv/usbdrv.c ****  */
 423:../lib/usbdrv/usbdrv.c **** static inline void usbProcessRx(uchar *data, uchar len)
 424:../lib/usbdrv/usbdrv.c **** {
 425:../lib/usbdrv/usbdrv.c **** usbRequest_t    *rq = (void *)data;
 426:../lib/usbdrv/usbdrv.c **** 
 427:../lib/usbdrv/usbdrv.c **** /* usbRxToken can be:
 428:../lib/usbdrv/usbdrv.c ****  * 0x2d 00101101 (USBPID_SETUP for setup data)
 429:../lib/usbdrv/usbdrv.c ****  * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)
 430:../lib/usbdrv/usbdrv.c ****  * 0...0x0f for OUT on endpoint X
 431:../lib/usbdrv/usbdrv.c ****  */
 432:../lib/usbdrv/usbdrv.c ****     DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */
 433:../lib/usbdrv/usbdrv.c ****     USB_RX_USER_HOOK(data, len)
 434:../lib/usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITEOUT
 435:../lib/usbdrv/usbdrv.c ****     if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
 436:../lib/usbdrv/usbdrv.c ****         usbFunctionWriteOut(data, len);
 437:../lib/usbdrv/usbdrv.c ****         return;
 438:../lib/usbdrv/usbdrv.c ****     }
 439:../lib/usbdrv/usbdrv.c **** #endif
 440:../lib/usbdrv/usbdrv.c ****     if(usbRxToken == (uchar)USBPID_SETUP){
 441:../lib/usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 442:../lib/usbdrv/usbdrv.c ****             return;
 443:../lib/usbdrv/usbdrv.c ****         usbMsgLen_t replyLen;
GAS LISTING /tmp/ccTUJtEn.s 			page 12


 444:../lib/usbdrv/usbdrv.c ****         usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
 445:../lib/usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 446:../lib/usbdrv/usbdrv.c ****         usbMsgFlags = 0;
 447:../lib/usbdrv/usbdrv.c ****         uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 448:../lib/usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 449:../lib/usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 450:../lib/usbdrv/usbdrv.c ****         }else{
 451:../lib/usbdrv/usbdrv.c ****             replyLen = usbDriverSetup(rq);
 452:../lib/usbdrv/usbdrv.c ****         }
 453:../lib/usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
 454:../lib/usbdrv/usbdrv.c ****         if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
 455:../lib/usbdrv/usbdrv.c ****             /* do some conditioning on replyLen, but on IN transfers only */
 456:../lib/usbdrv/usbdrv.c ****             if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
 457:../lib/usbdrv/usbdrv.c ****                 if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing *
 458:../lib/usbdrv/usbdrv.c ****                     replyLen = rq->wLength.bytes[0];
 459:../lib/usbdrv/usbdrv.c ****                 }else{
 460:../lib/usbdrv/usbdrv.c ****                     replyLen = rq->wLength.word;
 461:../lib/usbdrv/usbdrv.c ****                 }
 462:../lib/usbdrv/usbdrv.c ****             }
 463:../lib/usbdrv/usbdrv.c ****             usbMsgFlags = USB_FLG_USE_USER_RW;
 464:../lib/usbdrv/usbdrv.c ****         }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transf
 465:../lib/usbdrv/usbdrv.c **** #endif
 466:../lib/usbdrv/usbdrv.c ****         if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
 467:../lib/usbdrv/usbdrv.c ****             if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max 
 468:../lib/usbdrv/usbdrv.c ****                 replyLen = rq->wLength.bytes[0];
 469:../lib/usbdrv/usbdrv.c ****         }else{
 470:../lib/usbdrv/usbdrv.c ****             if(replyLen > rq->wLength.word)     /* limit length to max */
 471:../lib/usbdrv/usbdrv.c ****                 replyLen = rq->wLength.word;
 472:../lib/usbdrv/usbdrv.c ****         }
 473:../lib/usbdrv/usbdrv.c ****         usbMsgLen = replyLen;
 474:../lib/usbdrv/usbdrv.c ****     }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
 475:../lib/usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITE
 476:../lib/usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 477:../lib/usbdrv/usbdrv.c ****             uchar rval = usbFunctionWrite(data, len);
 478:../lib/usbdrv/usbdrv.c ****             if(rval == 0xff){   /* an error occurred */
 479:../lib/usbdrv/usbdrv.c ****                 usbTxLen = USBPID_STALL;
 480:../lib/usbdrv/usbdrv.c ****             }else if(rval != 0){    /* This was the final package */
 481:../lib/usbdrv/usbdrv.c ****                 usbMsgLen = 0;  /* answer with a zero-sized data packet */
 482:../lib/usbdrv/usbdrv.c ****             }
 483:../lib/usbdrv/usbdrv.c ****         }
 484:../lib/usbdrv/usbdrv.c **** #endif
 485:../lib/usbdrv/usbdrv.c ****     }
 486:../lib/usbdrv/usbdrv.c **** }
 487:../lib/usbdrv/usbdrv.c **** 
 488:../lib/usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 489:../lib/usbdrv/usbdrv.c **** 
 490:../lib/usbdrv/usbdrv.c **** /* This function is similar to usbFunctionRead(), but it's also called for
 491:../lib/usbdrv/usbdrv.c ****  * data handled automatically by the driver (e.g. descriptor reads).
 492:../lib/usbdrv/usbdrv.c ****  */
 493:../lib/usbdrv/usbdrv.c **** static uchar usbDeviceRead(uchar *data, uchar len)
 494:../lib/usbdrv/usbdrv.c **** {
 495:../lib/usbdrv/usbdrv.c ****     if(len > 0){    /* don't bother app with 0 sized reads */
 496:../lib/usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ
 497:../lib/usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 498:../lib/usbdrv/usbdrv.c ****             len = usbFunctionRead(data, len);
 499:../lib/usbdrv/usbdrv.c ****         }else
 500:../lib/usbdrv/usbdrv.c **** #endif
GAS LISTING /tmp/ccTUJtEn.s 			page 13


 501:../lib/usbdrv/usbdrv.c ****         {
 502:../lib/usbdrv/usbdrv.c ****             uchar i = len, *r = usbMsgPtr;
 503:../lib/usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 504:../lib/usbdrv/usbdrv.c ****                 do{
 505:../lib/usbdrv/usbdrv.c ****                     uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte
 506:../lib/usbdrv/usbdrv.c ****                     *data++ = c;
 507:../lib/usbdrv/usbdrv.c ****                     r++;
 508:../lib/usbdrv/usbdrv.c ****                 }while(--i);
 509:../lib/usbdrv/usbdrv.c ****             }else{  /* RAM data */
 510:../lib/usbdrv/usbdrv.c ****                 do{
 511:../lib/usbdrv/usbdrv.c ****                     *data++ = *r++;
 512:../lib/usbdrv/usbdrv.c ****                 }while(--i);
 513:../lib/usbdrv/usbdrv.c ****             }
 514:../lib/usbdrv/usbdrv.c ****             usbMsgPtr = r;
 515:../lib/usbdrv/usbdrv.c ****         }
 516:../lib/usbdrv/usbdrv.c ****     }
 517:../lib/usbdrv/usbdrv.c ****     return len;
 518:../lib/usbdrv/usbdrv.c **** }
 519:../lib/usbdrv/usbdrv.c **** 
 520:../lib/usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 521:../lib/usbdrv/usbdrv.c **** 
 522:../lib/usbdrv/usbdrv.c **** /* usbBuildTxBlock() is called when we have data to transmit and the
 523:../lib/usbdrv/usbdrv.c ****  * interrupt routine's transmit buffer is empty.
 524:../lib/usbdrv/usbdrv.c ****  */
 525:../lib/usbdrv/usbdrv.c **** static inline void usbBuildTxBlock(void)
 526:../lib/usbdrv/usbdrv.c **** {
 527:../lib/usbdrv/usbdrv.c **** usbMsgLen_t wantLen;
 528:../lib/usbdrv/usbdrv.c **** uchar       len;
 529:../lib/usbdrv/usbdrv.c **** 
 530:../lib/usbdrv/usbdrv.c ****     wantLen = usbMsgLen;
 531:../lib/usbdrv/usbdrv.c ****     if(wantLen > 8)
 532:../lib/usbdrv/usbdrv.c ****         wantLen = 8;
 533:../lib/usbdrv/usbdrv.c ****     usbMsgLen -= wantLen;
 534:../lib/usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 535:../lib/usbdrv/usbdrv.c ****     len = usbDeviceRead(usbTxBuf + 1, wantLen);
 536:../lib/usbdrv/usbdrv.c ****     if(len <= 8){           /* valid data packet */
 537:../lib/usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
 538:../lib/usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 539:../lib/usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 540:../lib/usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 541:../lib/usbdrv/usbdrv.c ****     }else{
 542:../lib/usbdrv/usbdrv.c ****         len = USBPID_STALL;   /* stall the endpoint */
 543:../lib/usbdrv/usbdrv.c ****         usbMsgLen = USB_NO_MSG;
 544:../lib/usbdrv/usbdrv.c ****     }
 545:../lib/usbdrv/usbdrv.c ****     usbTxLen = len;
 546:../lib/usbdrv/usbdrv.c ****     DBG2(0x20, usbTxBuf, len-1);
 547:../lib/usbdrv/usbdrv.c **** }
 548:../lib/usbdrv/usbdrv.c **** 
 549:../lib/usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 550:../lib/usbdrv/usbdrv.c **** 
 551:../lib/usbdrv/usbdrv.c **** static inline void usbHandleResetHook(uchar notResetState)
 552:../lib/usbdrv/usbdrv.c **** {
 553:../lib/usbdrv/usbdrv.c **** #ifdef USB_RESET_HOOK
 554:../lib/usbdrv/usbdrv.c **** static uchar    wasReset;
 555:../lib/usbdrv/usbdrv.c **** uchar           isReset = !notResetState;
 556:../lib/usbdrv/usbdrv.c **** 
 557:../lib/usbdrv/usbdrv.c ****     if(wasReset != isReset){
GAS LISTING /tmp/ccTUJtEn.s 			page 14


 558:../lib/usbdrv/usbdrv.c ****         USB_RESET_HOOK(isReset);
 559:../lib/usbdrv/usbdrv.c ****         wasReset = isReset;
 560:../lib/usbdrv/usbdrv.c ****     }
 561:../lib/usbdrv/usbdrv.c **** #else
 562:../lib/usbdrv/usbdrv.c ****     notResetState = notResetState;  // avoid compiler warning
 563:../lib/usbdrv/usbdrv.c **** #endif
 564:../lib/usbdrv/usbdrv.c **** }
 565:../lib/usbdrv/usbdrv.c **** 
 566:../lib/usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 567:../lib/usbdrv/usbdrv.c **** 
 568:../lib/usbdrv/usbdrv.c **** USB_PUBLIC void usbPoll(void)
 569:../lib/usbdrv/usbdrv.c **** {
 178               		.stabn	68,0,569,.LM10-.LFBB2
 179               	.LM10:
 180               	.LFBB2:
 181 0044 1F93      		push r17
 182 0046 CF93      		push r28
 183 0048 DF93      		push r29
 184 004a 00D0      		rcall .
 185 004c CDB7      		in r28,__SP_L__
 186 004e DEB7      		in r29,__SP_H__
 187               	/* prologue: function */
 188               	/* frame size = 2 */
 189               	/* stack size = 5 */
 190               	.L__stack_usage = 5
 570:../lib/usbdrv/usbdrv.c **** schar   len;
 571:../lib/usbdrv/usbdrv.c **** uchar   i;
 572:../lib/usbdrv/usbdrv.c **** 
 573:../lib/usbdrv/usbdrv.c ****     len = usbRxLen - 3;
 191               		.stabn	68,0,573,.LM11-.LFBB2
 192               	.LM11:
 193 0050 8091 0000 		lds r24,usbRxLen
 194 0054 8350      		subi r24,lo8(-(-3))
 574:../lib/usbdrv/usbdrv.c ****     if(len >= 0){
 195               		.stabn	68,0,574,.LM12-.LFBB2
 196               	.LM12:
 197 0056 87FD      		sbrc r24,7
 198 0058 00C0      		rjmp .L8
 575:../lib/usbdrv/usbdrv.c **** /* We could check CRC16 here -- but ACK has already been sent anyway. If you
 576:../lib/usbdrv/usbdrv.c ****  * need data integrity checks with this driver, check the CRC in your app
 577:../lib/usbdrv/usbdrv.c ****  * code and report errors back to the host. Since the ACK was already sent,
 578:../lib/usbdrv/usbdrv.c ****  * retries must be handled on application level.
 579:../lib/usbdrv/usbdrv.c ****  * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 580:../lib/usbdrv/usbdrv.c ****  */
 581:../lib/usbdrv/usbdrv.c ****         usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
 199               		.stabn	68,0,581,.LM13-.LFBB2
 200               	.LM13:
 201 005a 4091 0000 		lds r20,usbInputBufOffset
 202               	.LBB51:
 203               	.LBB52:
 440:../lib/usbdrv/usbdrv.c ****     if(usbRxToken == (uchar)USBPID_SETUP){
 204               		.stabn	68,0,440,.LM14-.LFBB2
 205               	.LM14:
 206 005e 9091 0000 		lds r25,usbRxToken
 207 0062 9D32      		cpi r25,lo8(45)
 208 0064 01F4      		brne .+2
 209 0066 00C0      		rjmp .L57
GAS LISTING /tmp/ccTUJtEn.s 			page 15


 210               	.L9:
 211               	.LBE52:
 212               	.LBE51:
 582:../lib/usbdrv/usbdrv.c **** #if USB_CFG_HAVE_FLOWCONTROL
 583:../lib/usbdrv/usbdrv.c ****         if(usbRxLen > 0)    /* only mark as available if not inactivated */
 584:../lib/usbdrv/usbdrv.c ****             usbRxLen = 0;
 585:../lib/usbdrv/usbdrv.c **** #else
 586:../lib/usbdrv/usbdrv.c ****         usbRxLen = 0;       /* mark rx buffer as available */
 213               		.stabn	68,0,586,.LM15-.LFBB2
 214               	.LM15:
 215 0068 1092 0000 		sts usbRxLen,__zero_reg__
 216               	.L8:
 587:../lib/usbdrv/usbdrv.c **** #endif
 588:../lib/usbdrv/usbdrv.c ****     }
 589:../lib/usbdrv/usbdrv.c ****     if(usbTxLen & 0x10){    /* transmit system idle */
 217               		.stabn	68,0,589,.LM16-.LFBB2
 218               	.LM16:
 219 006c 8091 0000 		lds r24,usbTxLen
 220 0070 84FF      		sbrs r24,4
 221 0072 00C0      		rjmp .L27
 590:../lib/usbdrv/usbdrv.c ****         if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
 222               		.stabn	68,0,590,.LM17-.LFBB2
 223               	.LM17:
 224 0074 6091 0000 		lds r22,usbMsgLen
 225 0078 6F3F      		cpi r22,lo8(-1)
 226 007a 01F0      		breq .L27
 227               	.LBB76:
 228               	.LBB77:
 531:../lib/usbdrv/usbdrv.c ****     if(wantLen > 8)
 229               		.stabn	68,0,531,.LM18-.LFBB2
 230               	.LM18:
 231 007c 6930      		cpi r22,lo8(9)
 232 007e 00F4      		brsh .+2
 233 0080 00C0      		rjmp .L58
 533:../lib/usbdrv/usbdrv.c ****     usbMsgLen -= wantLen;
 234               		.stabn	68,0,533,.LM19-.LFBB2
 235               	.LM19:
 236 0082 6850      		subi r22,lo8(-(-8))
 237 0084 6093 0000 		sts usbMsgLen,r22
 534:../lib/usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 238               		.stabn	68,0,534,.LM20-.LFBB2
 239               	.LM20:
 240 0088 8091 0000 		lds r24,usbTxBuf
 241 008c 98E8      		ldi r25,lo8(-120)
 242 008e 8927      		eor r24,r25
 243 0090 8093 0000 		sts usbTxBuf,r24
 244 0094 1CE0      		ldi r17,lo8(12)
 532:../lib/usbdrv/usbdrv.c ****         wantLen = 8;
 245               		.stabn	68,0,532,.LM21-.LFBB2
 246               	.LM21:
 247 0096 68E0      		ldi r22,lo8(8)
 248               	.L37:
 249               	.LBB78:
 250               	.LBB79:
 251               	.LBB80:
 502:../lib/usbdrv/usbdrv.c ****             uchar i = len, *r = usbMsgPtr;
 252               		.stabn	68,0,502,.LM22-.LFBB2
GAS LISTING /tmp/ccTUJtEn.s 			page 16


 253               	.LM22:
 254 0098 2091 0000 		lds r18,usbMsgPtr
 255 009c 3091 0000 		lds r19,usbMsgPtr+1
 256               	.LBE80:
 257               	.LBE79:
 503:../lib/usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 258               		.stabn	68,0,503,.LM23-.LFBB2
 259               	.LM23:
 260 00a0 8091 0000 		lds r24,usbMsgFlags
 261               	.LBB85:
 262               	.LBB83:
 263 00a4 86FF      		sbrs r24,6
 264 00a6 00C0      		rjmp .L30
 265 00a8 F901      		movw r30,r18
 266 00aa 862F      		mov r24,r22
 267 00ac A0E0      		ldi r26,lo8(usbTxBuf+1)
 268 00ae B0E0      		ldi r27,hi8(usbTxBuf+1)
 269               	.L31:
 270               	.LBB81:
 271               	.LBB82:
 505:../lib/usbdrv/usbdrv.c ****                     uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte
 272               		.stabn	68,0,505,.LM24-.LFBB2
 273               	.LM24:
 274               	/* #APP */
 275               	 ;  505 "../lib/usbdrv/usbdrv.c" 1
 276 00b0 9491      		lpm r25, Z
 277               		
 278               	 ;  0 "" 2
 279               	/* #NOAPP */
 280               	.LBE82:
 506:../lib/usbdrv/usbdrv.c ****                     *data++ = c;
 281               		.stabn	68,0,506,.LM25-.LFBB2
 282               	.LM25:
 283 00b2 9D93      		st X+,r25
 507:../lib/usbdrv/usbdrv.c ****                     r++;
 284               		.stabn	68,0,507,.LM26-.LFBB2
 285               	.LM26:
 286 00b4 3196      		adiw r30,1
 287               	.LBE81:
 508:../lib/usbdrv/usbdrv.c ****                 }while(--i);
 288               		.stabn	68,0,508,.LM27-.LFBB2
 289               	.LM27:
 290 00b6 8150      		subi r24,lo8(-(-1))
 291 00b8 01F4      		brne .L31
 292               	.L56:
 568:../lib/usbdrv/usbdrv.c **** USB_PUBLIC void usbPoll(void)
 293               		.stabn	68,0,568,.LM28-.LFBB2
 294               	.LM28:
 295 00ba 862F      		mov r24,r22
 296 00bc 8150      		subi r24,lo8(-(-1))
 297 00be 90E0      		ldi r25,0
 298 00c0 0196      		adiw r24,1
 299 00c2 820F      		add r24,r18
 300 00c4 931F      		adc r25,r19
 514:../lib/usbdrv/usbdrv.c ****             usbMsgPtr = r;
 301               		.stabn	68,0,514,.LM29-.LFBB2
 302               	.LM29:
GAS LISTING /tmp/ccTUJtEn.s 			page 17


 303 00c6 9093 0000 		sts usbMsgPtr+1,r25
 304 00ca 8093 0000 		sts usbMsgPtr,r24
 305               	.LBE83:
 306               	.LBE85:
 307               	.LBE78:
 537:../lib/usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
 308               		.stabn	68,0,537,.LM30-.LFBB2
 309               	.LM30:
 310 00ce 80E0      		ldi r24,lo8(usbTxBuf+1)
 311 00d0 90E0      		ldi r25,hi8(usbTxBuf+1)
 312 00d2 0E94 0000 		call usbCrc16Append
 539:../lib/usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 313               		.stabn	68,0,539,.LM31-.LFBB2
 314               	.LM31:
 315 00d6 1C30      		cpi r17,lo8(12)
 316 00d8 01F0      		breq .+2
 317 00da 00C0      		rjmp .L38
 318               	.L34:
 545:../lib/usbdrv/usbdrv.c ****     usbTxLen = len;
 319               		.stabn	68,0,545,.LM32-.LFBB2
 320               	.LM32:
 321 00dc 1093 0000 		sts usbTxLen,r17
 322               	.L27:
 538:../lib/usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 323               		.stabn	68,0,538,.LM33-.LFBB2
 324               	.LM33:
 325 00e0 94E1      		ldi r25,lo8(20)
 326               	.L36:
 327               	.LBE77:
 328               	.LBE76:
 329               	.LBB91:
 591:../lib/usbdrv/usbdrv.c ****             usbBuildTxBlock();
 592:../lib/usbdrv/usbdrv.c ****         }
 593:../lib/usbdrv/usbdrv.c ****     }
 594:../lib/usbdrv/usbdrv.c ****     for(i = 20; i > 0; i--){
 595:../lib/usbdrv/usbdrv.c ****         uchar usbLineStatus = USBIN & USBMASK;
 330               		.stabn	68,0,595,.LM34-.LFBB2
 331               	.LM34:
 332 00e2 89B1      		in r24,0x9
 333 00e4 8471      		andi r24,lo8(20)
 596:../lib/usbdrv/usbdrv.c ****         if(usbLineStatus != 0)  /* SE0 has ended */
 334               		.stabn	68,0,596,.LM35-.LFBB2
 335               	.LM35:
 336 00e6 01F4      		brne .L7
 337 00e8 9150      		subi r25,lo8(-(-1))
 338               	.LBE91:
 594:../lib/usbdrv/usbdrv.c ****     for(i = 20; i > 0; i--){
 339               		.stabn	68,0,594,.LM36-.LFBB2
 340               	.LM36:
 341 00ea 01F4      		brne .L36
 597:../lib/usbdrv/usbdrv.c ****             goto isNotReset;
 598:../lib/usbdrv/usbdrv.c ****     }
 599:../lib/usbdrv/usbdrv.c ****     /* RESET condition, called multiple times during reset */
 600:../lib/usbdrv/usbdrv.c ****     usbNewDeviceAddr = 0;
 342               		.stabn	68,0,600,.LM37-.LFBB2
 343               	.LM37:
 344 00ec 1092 0000 		sts usbNewDeviceAddr,__zero_reg__
GAS LISTING /tmp/ccTUJtEn.s 			page 18


 601:../lib/usbdrv/usbdrv.c ****     usbDeviceAddr = 0;
 345               		.stabn	68,0,601,.LM38-.LFBB2
 346               	.LM38:
 347 00f0 1092 0000 		sts usbDeviceAddr,__zero_reg__
 348               	.L35:
 349               	.L7:
 350               	/* epilogue start */
 602:../lib/usbdrv/usbdrv.c ****     usbResetStall();
 603:../lib/usbdrv/usbdrv.c ****     DBG1(0xff, 0, 0);
 604:../lib/usbdrv/usbdrv.c **** isNotReset:
 605:../lib/usbdrv/usbdrv.c ****     usbHandleResetHook(i);
 606:../lib/usbdrv/usbdrv.c **** }
 351               		.stabn	68,0,606,.LM39-.LFBB2
 352               	.LM39:
 353 00f4 0F90      		pop __tmp_reg__
 354 00f6 0F90      		pop __tmp_reg__
 355 00f8 DF91      		pop r29
 356 00fa CF91      		pop r28
 357 00fc 1F91      		pop r17
 358 00fe 0895      		ret
 359               	.L57:
 360               	.LBB92:
 361               	.LBB73:
 362               	.LBB53:
 441:../lib/usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 363               		.stabn	68,0,441,.LM40-.LFBB2
 364               	.LM40:
 365 0100 8830      		cpi r24,lo8(8)
 366 0102 01F0      		breq .+2
 367 0104 00C0      		rjmp .L9
 368               	.LBE53:
 369               	.LBE73:
 370               	.LBE92:
 581:../lib/usbdrv/usbdrv.c ****         usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
 371               		.stabn	68,0,581,.LM41-.LFBB2
 372               	.LM41:
 373 0106 2CE0      		ldi r18,lo8(12)
 374 0108 30E0      		ldi r19,0
 375 010a 241B      		sub r18,r20
 376 010c 3109      		sbc r19,__zero_reg__
 377 010e 2050      		subi r18,lo8(-(usbRxBuf))
 378 0110 3040      		sbci r19,hi8(-(usbRxBuf))
 379               	.LBB93:
 380               	.LBB74:
 381               	.LBB71:
 444:../lib/usbdrv/usbdrv.c ****         usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
 382               		.stabn	68,0,444,.LM42-.LFBB2
 383               	.LM42:
 384 0112 83EC      		ldi r24,lo8(-61)
 385 0114 8093 0000 		sts usbTxBuf,r24
 445:../lib/usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 386               		.stabn	68,0,445,.LM43-.LFBB2
 387               	.LM43:
 388 0118 8AE5      		ldi r24,lo8(90)
 389 011a 8093 0000 		sts usbTxLen,r24
 446:../lib/usbdrv/usbdrv.c ****         usbMsgFlags = 0;
 390               		.stabn	68,0,446,.LM44-.LFBB2
GAS LISTING /tmp/ccTUJtEn.s 			page 19


 391               	.LM44:
 392 011e 1092 0000 		sts usbMsgFlags,__zero_reg__
 447:../lib/usbdrv/usbdrv.c ****         uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 393               		.stabn	68,0,447,.LM45-.LFBB2
 394               	.LM45:
 395 0122 F901      		movw r30,r18
 396 0124 8081      		ld r24,Z
 397 0126 8076      		andi r24,lo8(96)
 448:../lib/usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 398               		.stabn	68,0,448,.LM46-.LFBB2
 399               	.LM46:
 400 0128 01F4      		brne .L59
 401               	.LBB54:
 402               	.LBB55:
 366:../lib/usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 403               		.stabn	68,0,366,.LM47-.LFBB2
 404               	.LM47:
 405 012a F901      		movw r30,r18
 406 012c 9281      		ldd r25,Z+2
 371:../lib/usbdrv/usbdrv.c ****     dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 407               		.stabn	68,0,371,.LM48-.LFBB2
 408               	.LM48:
 409 012e 1092 0000 		sts usbTxBuf+9,__zero_reg__
 410               	.LBB56:
 372:../lib/usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 411               		.stabn	68,0,372,.LM49-.LFBB2
 412               	.LM49:
 413 0132 8181      		ldd r24,Z+1
 373:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 414               		.stabn	68,0,373,.LM50-.LFBB2
 415               	.LM50:
 416 0134 8111      		cpse r24,__zero_reg__
 417 0136 00C0      		rjmp .L12
 418               	.LBB57:
 381:../lib/usbdrv/usbdrv.c ****         dataPtr[1] = 0;
 419               		.stabn	68,0,381,.LM51-.LFBB2
 420               	.LM51:
 421 0138 1092 0000 		sts usbTxBuf+10,__zero_reg__
 365:../lib/usbdrv/usbdrv.c **** uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
 422               		.stabn	68,0,365,.LM52-.LFBB2
 423               	.LM52:
 424 013c 40E0      		ldi r20,lo8(usbTxBuf+9)
 425 013e 50E0      		ldi r21,hi8(usbTxBuf+9)
 382:../lib/usbdrv/usbdrv.c ****         len = 2;
 426               		.stabn	68,0,382,.LM53-.LFBB2
 427               	.LM53:
 428 0140 82E0      		ldi r24,lo8(2)
 429               	.L13:
 430               	.LBE57:
 431               	.LBE56:
 412:../lib/usbdrv/usbdrv.c ****     usbMsgPtr = dataPtr;
 432               		.stabn	68,0,412,.LM54-.LFBB2
 433               	.LM54:
 434 0142 5093 0000 		sts usbMsgPtr+1,r21
 435 0146 4093 0000 		sts usbMsgPtr,r20
 436               	.L23:
 437               	.L11:
GAS LISTING /tmp/ccTUJtEn.s 			page 20


 438               	.LBE55:
 439               	.LBE54:
 467:../lib/usbdrv/usbdrv.c ****             if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max 
 440               		.stabn	68,0,467,.LM55-.LFBB2
 441               	.LM55:
 442 014a F901      		movw r30,r18
 443 014c 9781      		ldd r25,Z+7
 444 014e 9111      		cpse r25,__zero_reg__
 445 0150 00C0      		rjmp .L25
 446 0152 9681      		ldd r25,Z+6
 447 0154 9817      		cp r25,r24
 448 0156 00F4      		brsh .L25
 449 0158 892F      		mov r24,r25
 450               	.L25:
 473:../lib/usbdrv/usbdrv.c ****         usbMsgLen = replyLen;
 451               		.stabn	68,0,473,.LM56-.LFBB2
 452               	.LM56:
 453 015a 8093 0000 		sts usbMsgLen,r24
 454 015e 00C0      		rjmp .L9
 455               	.L58:
 456               	.LBE71:
 457               	.LBE74:
 458               	.LBE93:
 459               	.LBB94:
 460               	.LBB90:
 533:../lib/usbdrv/usbdrv.c ****     usbMsgLen -= wantLen;
 461               		.stabn	68,0,533,.LM57-.LFBB2
 462               	.LM57:
 463 0160 1092 0000 		sts usbMsgLen,__zero_reg__
 534:../lib/usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 464               		.stabn	68,0,534,.LM58-.LFBB2
 465               	.LM58:
 466 0164 8091 0000 		lds r24,usbTxBuf
 467 0168 98E8      		ldi r25,lo8(-120)
 468 016a 8927      		eor r24,r25
 469 016c 8093 0000 		sts usbTxBuf,r24
 470               	.LBB88:
 471               	.LBB86:
 495:../lib/usbdrv/usbdrv.c ****     if(len > 0){    /* don't bother app with 0 sized reads */
 472               		.stabn	68,0,495,.LM59-.LFBB2
 473               	.LM59:
 474 0170 6111      		cpse r22,__zero_reg__
 475 0172 00C0      		rjmp .L60
 476               	.LBE86:
 477               	.LBE88:
 537:../lib/usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
 478               		.stabn	68,0,537,.LM60-.LFBB2
 479               	.LM60:
 480 0174 60E0      		ldi r22,0
 481 0176 80E0      		ldi r24,lo8(usbTxBuf+1)
 482 0178 90E0      		ldi r25,hi8(usbTxBuf+1)
 483 017a 0E94 0000 		call usbCrc16Append
 538:../lib/usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 484               		.stabn	68,0,538,.LM61-.LFBB2
 485               	.LM61:
 486 017e 14E0      		ldi r17,lo8(4)
 487               	.L38:
GAS LISTING /tmp/ccTUJtEn.s 			page 21


 540:../lib/usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 488               		.stabn	68,0,540,.LM62-.LFBB2
 489               	.LM62:
 490 0180 8FEF      		ldi r24,lo8(-1)
 491 0182 8093 0000 		sts usbMsgLen,r24
 492 0186 00C0      		rjmp .L34
 493               	.L30:
 494 0188 D901      		movw r26,r18
 495               	.LBB89:
 496               	.LBB87:
 497               	.LBB84:
 503:../lib/usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 498               		.stabn	68,0,503,.LM63-.LFBB2
 499               	.LM63:
 500 018a 862F      		mov r24,r22
 501 018c E0E0      		ldi r30,lo8(usbTxBuf+1)
 502 018e F0E0      		ldi r31,hi8(usbTxBuf+1)
 503               	.L33:
 511:../lib/usbdrv/usbdrv.c ****                     *data++ = *r++;
 504               		.stabn	68,0,511,.LM64-.LFBB2
 505               	.LM64:
 506 0190 9D91      		ld r25,X+
 507 0192 9193      		st Z+,r25
 512:../lib/usbdrv/usbdrv.c ****                 }while(--i);
 508               		.stabn	68,0,512,.LM65-.LFBB2
 509               	.LM65:
 510 0194 8150      		subi r24,lo8(-(-1))
 511 0196 01F4      		brne .L33
 512 0198 00C0      		rjmp .L56
 513               	.L59:
 514               	.LBE84:
 515               	.LBE87:
 516               	.LBE89:
 517               	.LBE90:
 518               	.LBE94:
 519               	.LBB95:
 520               	.LBB75:
 521               	.LBB72:
 449:../lib/usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 522               		.stabn	68,0,449,.LM66-.LFBB2
 523               	.LM66:
 524 019a C901      		movw r24,r18
 525 019c 2983      		std Y+1,r18
 526 019e 3A83      		std Y+2,r19
 527 01a0 0E94 0000 		call usbFunctionSetup
 528 01a4 2981      		ldd r18,Y+1
 529 01a6 3A81      		ldd r19,Y+2
 530 01a8 00C0      		rjmp .L11
 531               	.L60:
 532 01aa 162F      		mov r17,r22
 533 01ac 1C5F      		subi r17,lo8(-(4))
 534 01ae 00C0      		rjmp .L37
 535               	.L12:
 536               	.LBB70:
 537               	.LBB68:
 538               	.LBB66:
 390:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
GAS LISTING /tmp/ccTUJtEn.s 			page 22


 539               		.stabn	68,0,390,.LM67-.LFBB2
 540               	.LM67:
 541 01b0 8530      		cpi r24,lo8(5)
 542 01b2 01F0      		breq .L61
 393:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
 543               		.stabn	68,0,393,.LM68-.LFBB2
 544               	.LM68:
 545 01b4 8630      		cpi r24,lo8(6)
 546 01b6 01F0      		breq .L62
 396:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
 547               		.stabn	68,0,396,.LM69-.LFBB2
 548               	.LM69:
 549 01b8 8830      		cpi r24,lo8(8)
 550 01ba 01F0      		breq .L41
 399:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
 551               		.stabn	68,0,399,.LM70-.LFBB2
 552               	.LM70:
 553 01bc 8930      		cpi r24,lo8(9)
 554 01be 01F0      		breq .L63
 402:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
 555               		.stabn	68,0,402,.LM71-.LFBB2
 556               	.LM71:
 557 01c0 8A30      		cpi r24,lo8(10)
 558 01c2 01F0      		breq .L42
 405:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
 559               		.stabn	68,0,405,.LM72-.LFBB2
 560               	.LM72:
 561 01c4 8B30      		cpi r24,lo8(11)
 562 01c6 01F0      		breq .L64
 365:../lib/usbdrv/usbdrv.c **** uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
 563               		.stabn	68,0,365,.LM73-.LFBB2
 564               	.LM73:
 565 01c8 40E0      		ldi r20,lo8(usbTxBuf+9)
 566 01ca 50E0      		ldi r21,hi8(usbTxBuf+9)
 364:../lib/usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 567               		.stabn	68,0,364,.LM74-.LFBB2
 568               	.LM74:
 569 01cc 80E0      		ldi r24,0
 570 01ce 00C0      		rjmp .L13
 571               	.L61:
 391:../lib/usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 572               		.stabn	68,0,391,.LM75-.LFBB2
 573               	.LM75:
 574 01d0 9093 0000 		sts usbNewDeviceAddr,r25
 365:../lib/usbdrv/usbdrv.c **** uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
 575               		.stabn	68,0,365,.LM76-.LFBB2
 576               	.LM76:
 577 01d4 40E0      		ldi r20,lo8(usbTxBuf+9)
 578 01d6 50E0      		ldi r21,hi8(usbTxBuf+9)
 364:../lib/usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 579               		.stabn	68,0,364,.LM77-.LFBB2
 580               	.LM77:
 581 01d8 80E0      		ldi r24,0
 582 01da 00C0      		rjmp .L13
 583               	.L41:
 397:../lib/usbdrv/usbdrv.c ****         dataPtr = &usbConfiguration;  /* send current configuration value */
 584               		.stabn	68,0,397,.LM78-.LFBB2
GAS LISTING /tmp/ccTUJtEn.s 			page 23


 585               	.LM78:
 586 01dc 40E0      		ldi r20,lo8(usbConfiguration)
 587 01de 50E0      		ldi r21,hi8(usbConfiguration)
 398:../lib/usbdrv/usbdrv.c ****         len = 1;
 588               		.stabn	68,0,398,.LM79-.LFBB2
 589               	.LM79:
 590 01e0 81E0      		ldi r24,lo8(1)
 591 01e2 00C0      		rjmp .L13
 592               	.L42:
 365:../lib/usbdrv/usbdrv.c **** uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
 593               		.stabn	68,0,365,.LM80-.LFBB2
 594               	.LM80:
 595 01e4 40E0      		ldi r20,lo8(usbTxBuf+9)
 596 01e6 50E0      		ldi r21,hi8(usbTxBuf+9)
 403:../lib/usbdrv/usbdrv.c ****         len = 1;
 597               		.stabn	68,0,403,.LM81-.LFBB2
 598               	.LM81:
 599 01e8 81E0      		ldi r24,lo8(1)
 600 01ea 00C0      		rjmp .L13
 601               	.L63:
 400:../lib/usbdrv/usbdrv.c ****         usbConfiguration = value;
 602               		.stabn	68,0,400,.LM82-.LFBB2
 603               	.LM82:
 604 01ec 9093 0000 		sts usbConfiguration,r25
 365:../lib/usbdrv/usbdrv.c **** uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
 605               		.stabn	68,0,365,.LM83-.LFBB2
 606               	.LM83:
 607 01f0 40E0      		ldi r20,lo8(usbTxBuf+9)
 608 01f2 50E0      		ldi r21,hi8(usbTxBuf+9)
 364:../lib/usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 609               		.stabn	68,0,364,.LM84-.LFBB2
 610               	.LM84:
 611 01f4 80E0      		ldi r24,0
 612 01f6 00C0      		rjmp .L13
 613               	.L64:
 614               	.LBB58:
 615               	.LBB59:
 200:../lib/usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 616               		.stabn	68,0,200,.LM85-.LFBB2
 617               	.LM85:
 618 01f8 8BE4      		ldi r24,lo8(75)
 619 01fa 8093 0000 		sts usbTxStatus1+1,r24
 365:../lib/usbdrv/usbdrv.c **** uchar   *dataPtr = usbTxBuf + 9;    /* there are 2 bytes free space at the end of the buffer */
 620               		.stabn	68,0,365,.LM86-.LFBB2
 621               	.LM86:
 622 01fe 40E0      		ldi r20,lo8(usbTxBuf+9)
 623 0200 50E0      		ldi r21,hi8(usbTxBuf+9)
 364:../lib/usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 624               		.stabn	68,0,364,.LM87-.LFBB2
 625               	.LM87:
 626 0202 80E0      		ldi r24,0
 627 0204 00C0      		rjmp .L13
 628               	.L62:
 629               	.LBE59:
 630               	.LBE58:
 631               	.LBE66:
 632               	.LBE68:
GAS LISTING /tmp/ccTUJtEn.s 			page 24


 607:../lib/usbdrv/usbdrv.c **** 
 608:../lib/usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 609:../lib/usbdrv/usbdrv.c **** 
 610:../lib/usbdrv/usbdrv.c **** USB_PUBLIC void usbInit(void)
 611:../lib/usbdrv/usbdrv.c **** {
 612:../lib/usbdrv/usbdrv.c **** #if USB_INTR_CFG_SET != 0
 613:../lib/usbdrv/usbdrv.c ****     USB_INTR_CFG |= USB_INTR_CFG_SET;
 614:../lib/usbdrv/usbdrv.c **** #endif
 615:../lib/usbdrv/usbdrv.c **** #if USB_INTR_CFG_CLR != 0
 616:../lib/usbdrv/usbdrv.c ****     USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
 617:../lib/usbdrv/usbdrv.c **** #endif
 618:../lib/usbdrv/usbdrv.c ****     USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
 619:../lib/usbdrv/usbdrv.c ****     usbResetDataToggling();
 620:../lib/usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 621:../lib/usbdrv/usbdrv.c ****     usbTxLen1 = USBPID_NAK;
 622:../lib/usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 623:../lib/usbdrv/usbdrv.c ****     usbTxLen3 = USBPID_NAK;
 624:../lib/usbdrv/usbdrv.c **** #endif
 625:../lib/usbdrv/usbdrv.c **** #endif
 626:../lib/usbdrv/usbdrv.c **** }
 633               		.stabn	68,0,626,.LM88-.LFBB2
 634               	.LM88:
 635 0206 F901      		movw r30,r18
 636 0208 8381      		ldd r24,Z+3
 637               	.LBB69:
 638               	.LBB67:
 639               	.LBB60:
 640               	.LBB61:
 641               	.LBB62:
 317:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
 642               		.stabn	68,0,317,.LM89-.LFBB2
 643               	.LM89:
 644 020a 8130      		cpi r24,lo8(1)
 645 020c 01F0      		breq .L65
 319:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 646               		.stabn	68,0,319,.LM90-.LFBB2
 647               	.LM90:
 648 020e 8230      		cpi r24,lo8(2)
 649 0210 01F0      		breq .L66
 321:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 650               		.stabn	68,0,321,.LM91-.LFBB2
 651               	.LM91:
 652 0212 8330      		cpi r24,lo8(3)
 653 0214 01F0      		breq .L67
 343:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
 654               		.stabn	68,0,343,.LM92-.LFBB2
 655               	.LM92:
 656 0216 8132      		cpi r24,lo8(33)
 657 0218 01F0      		breq .L68
 345:../lib/usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
 658               		.stabn	68,0,345,.LM93-.LFBB2
 659               	.LM93:
 660 021a 8232      		cpi r24,lo8(34)
 661 021c 01F0      		breq .L69
 662               	.L40:
 313:../lib/usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 663               		.stabn	68,0,313,.LM94-.LFBB2
GAS LISTING /tmp/ccTUJtEn.s 			page 25


 664               	.LM94:
 665 021e 80E0      		ldi r24,0
 666               	.L17:
 667               	.LBE62:
 353:../lib/usbdrv/usbdrv.c ****     usbMsgFlags = flags;
 668               		.stabn	68,0,353,.LM95-.LFBB2
 669               	.LM95:
 670 0220 90E4      		ldi r25,lo8(64)
 671 0222 9093 0000 		sts usbMsgFlags,r25
 672 0226 00C0      		rjmp .L11
 673               	.L65:
 674               	.LBB65:
 318:../lib/usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 675               		.stabn	68,0,318,.LM96-.LFBB2
 676               	.LM96:
 677 0228 80E0      		ldi r24,lo8(usbDescriptorDevice)
 678 022a 90E0      		ldi r25,hi8(usbDescriptorDevice)
 679 022c 9093 0000 		sts usbMsgPtr+1,r25
 680 0230 8093 0000 		sts usbMsgPtr,r24
 681 0234 82E1      		ldi r24,lo8(18)
 682 0236 00C0      		rjmp .L17
 683               	.L69:
 346:../lib/usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
 684               		.stabn	68,0,346,.LM97-.LFBB2
 685               	.LM97:
 686 0238 80E0      		ldi r24,lo8(usbDescriptorHidReport)
 687 023a 90E0      		ldi r25,hi8(usbDescriptorHidReport)
 688 023c 9093 0000 		sts usbMsgPtr+1,r25
 689 0240 8093 0000 		sts usbMsgPtr,r24
 690 0244 84E3      		ldi r24,lo8(52)
 691 0246 00C0      		rjmp .L17
 692               	.L68:
 344:../lib/usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
 693               		.stabn	68,0,344,.LM98-.LFBB2
 694               	.LM98:
 695 0248 80E0      		ldi r24,lo8(usbDescriptorConfiguration+18)
 696 024a 90E0      		ldi r25,hi8(usbDescriptorConfiguration+18)
 697 024c 9093 0000 		sts usbMsgPtr+1,r25
 698 0250 8093 0000 		sts usbMsgPtr,r24
 699 0254 89E0      		ldi r24,lo8(9)
 700 0256 00C0      		rjmp .L17
 701               	.L67:
 702               	.LBB63:
 328:../lib/usbdrv/usbdrv.c ****         SWITCH_CASE(0)
 703               		.stabn	68,0,328,.LM99-.LFBB2
 704               	.LM99:
 705 0258 9111      		cpse r25,__zero_reg__
 706 025a 00C0      		rjmp .L20
 329:../lib/usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 707               		.stabn	68,0,329,.LM100-.LFBB2
 708               	.LM100:
 709 025c 80E0      		ldi r24,lo8(usbDescriptorString0)
 710 025e 90E0      		ldi r25,hi8(usbDescriptorString0)
 711 0260 9093 0000 		sts usbMsgPtr+1,r25
 712 0264 8093 0000 		sts usbMsgPtr,r24
 713 0268 84E0      		ldi r24,lo8(4)
 714 026a 00C0      		rjmp .L17
GAS LISTING /tmp/ccTUJtEn.s 			page 26


 715               	.L66:
 716               	.LBE63:
 320:../lib/usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 717               		.stabn	68,0,320,.LM101-.LFBB2
 718               	.LM101:
 719 026c 80E0      		ldi r24,lo8(usbDescriptorConfiguration)
 720 026e 90E0      		ldi r25,hi8(usbDescriptorConfiguration)
 721 0270 9093 0000 		sts usbMsgPtr+1,r25
 722 0274 8093 0000 		sts usbMsgPtr,r24
 723 0278 82E2      		ldi r24,lo8(34)
 724 027a 00C0      		rjmp .L17
 725               	.L20:
 726               	.LBB64:
 330:../lib/usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 727               		.stabn	68,0,330,.LM102-.LFBB2
 728               	.LM102:
 729 027c 9130      		cpi r25,lo8(1)
 730 027e 01F0      		breq .L70
 332:../lib/usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 731               		.stabn	68,0,332,.LM103-.LFBB2
 732               	.LM103:
 733 0280 9230      		cpi r25,lo8(2)
 734 0282 01F4      		brne .L40
 333:../lib/usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 735               		.stabn	68,0,333,.LM104-.LFBB2
 736               	.LM104:
 737 0284 80E0      		ldi r24,lo8(usbDescriptorStringDevice)
 738 0286 90E0      		ldi r25,hi8(usbDescriptorStringDevice)
 739 0288 9093 0000 		sts usbMsgPtr+1,r25
 740 028c 8093 0000 		sts usbMsgPtr,r24
 741 0290 8CE0      		ldi r24,lo8(12)
 742 0292 00C0      		rjmp .L17
 743               	.L70:
 331:../lib/usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
 744               		.stabn	68,0,331,.LM105-.LFBB2
 745               	.LM105:
 746 0294 80E0      		ldi r24,lo8(usbDescriptorStringVendor)
 747 0296 90E0      		ldi r25,hi8(usbDescriptorStringVendor)
 748 0298 9093 0000 		sts usbMsgPtr+1,r25
 749 029c 8093 0000 		sts usbMsgPtr,r24
 750 02a0 82E1      		ldi r24,lo8(18)
 751 02a2 00C0      		rjmp .L17
 752               	.LBE64:
 753               	.LBE65:
 754               	.LBE61:
 755               	.LBE60:
 756               	.LBE67:
 757               	.LBE69:
 758               	.LBE70:
 759               	.LBE72:
 760               	.LBE75:
 761               	.LBE95:
 762               		.size	usbPoll, .-usbPoll
 763               		.stabs	"dataPtr:r(0,16)",64,0,365,20
 764               		.stabs	"value:r(0,11)",64,0,366,25
 765               		.stabn	192,0,0,.LBB55-.LFBB2
 766               		.stabs	"_cmd:r(0,11)",64,0,372,24
GAS LISTING /tmp/ccTUJtEn.s 			page 27


 767               		.stabn	192,0,0,.LBB56-.LFBB2
 768               		.stabs	"_cmd:r(0,11)",64,0,316,24
 769               		.stabn	192,0,0,.LBB62-.LFBB2
 770               		.stabn	224,0,0,.LBE62-.LFBB2
 771               		.stabs	"_cmd:r(0,11)",64,0,316,24
 772               		.stabn	192,0,0,.LBB65-.LFBB2
 773               		.stabn	224,0,0,.LBE65-.LFBB2
 774               		.stabn	224,0,0,.LBE56-.LFBB2
 775               		.stabs	"_cmd:r(0,11)",64,0,372,24
 776               		.stabn	192,0,0,.LBB66-.LFBB2
 777               		.stabn	224,0,0,.LBE66-.LFBB2
 778               		.stabs	"_cmd:r(0,11)",64,0,372,24
 779               		.stabn	192,0,0,.LBB67-.LFBB2
 780               		.stabn	224,0,0,.LBE67-.LFBB2
 781               		.stabn	224,0,0,.LBE55-.LFBB2
 782               		.stabs	"dataPtr:r(0,16)",64,0,365,20
 783               		.stabs	"value:r(0,11)",64,0,366,25
 784               		.stabn	192,0,0,.LBB68-.LFBB2
 785               		.stabn	224,0,0,.LBE68-.LFBB2
 786               		.stabs	"dataPtr:r(0,16)",64,0,365,20
 787               		.stabs	"value:r(0,11)",64,0,366,25
 788               		.stabn	192,0,0,.LBB69-.LFBB2
 789               		.stabn	224,0,0,.LBE69-.LFBB2
 790               		.stabs	"len:r(0,11)",64,0,528,17
 791               		.stabn	192,0,0,.LBB77-.LFBB2
 792               		.stabn	224,0,0,.LBE77-.LFBB2
 793               		.stabs	"len:r(0,11)",64,0,528,17
 794               		.stabn	192,0,0,.LBB90-.LFBB2
 795               		.stabn	224,0,0,.LBE90-.LFBB2
 796               	.Lscope2:
 797               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 798               		.stabd	78,0,0
 799               		.stabs	"usbInit:F(0,15)",36,0,610,usbInit
 800               	.global	usbInit
 801               		.type	usbInit, @function
 802               	usbInit:
 803               		.stabd	46,0,0
 611:../lib/usbdrv/usbdrv.c **** {
 804               		.stabn	68,0,611,.LM106-.LFBB3
 805               	.LM106:
 806               	.LFBB3:
 807               	/* prologue: function */
 808               	/* frame size = 0 */
 809               	/* stack size = 0 */
 810               	.L__stack_usage = 0
 613:../lib/usbdrv/usbdrv.c ****     USB_INTR_CFG |= USB_INTR_CFG_SET;
 811               		.stabn	68,0,613,.LM107-.LFBB3
 812               	.LM107:
 813 02a4 E9E6      		ldi r30,lo8(105)
 814 02a6 F0E0      		ldi r31,0
 815 02a8 8081      		ld r24,Z
 816 02aa 8260      		ori r24,lo8(2)
 817 02ac 8083      		st Z,r24
 618:../lib/usbdrv/usbdrv.c ****     USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
 818               		.stabn	68,0,618,.LM108-.LFBB3
 819               	.LM108:
 820 02ae E89A      		sbi 0x1d,0
GAS LISTING /tmp/ccTUJtEn.s 			page 28


 821               	.LBB96:
 822               	.LBB97:
 200:../lib/usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 823               		.stabn	68,0,200,.LM109-.LFBB3
 824               	.LM109:
 825 02b0 8BE4      		ldi r24,lo8(75)
 826 02b2 8093 0000 		sts usbTxStatus1+1,r24
 827               	.LBE97:
 828               	.LBE96:
 621:../lib/usbdrv/usbdrv.c ****     usbTxLen1 = USBPID_NAK;
 829               		.stabn	68,0,621,.LM110-.LFBB3
 830               	.LM110:
 831 02b6 8AE5      		ldi r24,lo8(90)
 832 02b8 8093 0000 		sts usbTxStatus1,r24
 833 02bc 0895      		ret
 834               		.size	usbInit, .-usbInit
 835               	.Lscope3:
 836               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 837               		.stabd	78,0,0
 838               	.global	usbDescriptorConfiguration
 839               		.section	.progmem.data,"a",@progbits
 840               		.type	usbDescriptorConfiguration, @object
 841               		.size	usbDescriptorConfiguration, 34
 842               	usbDescriptorConfiguration:
 843 0000 09        		.byte	9
 844 0001 02        		.byte	2
 845 0002 22        		.byte	34
 846 0003 00        		.byte	0
 847 0004 01        		.byte	1
 848 0005 01        		.byte	1
 849 0006 00        		.byte	0
 850 0007 80        		.byte	-128
 851 0008 0A        		.byte	10
 852 0009 09        		.byte	9
 853 000a 04        		.byte	4
 854 000b 00        		.byte	0
 855 000c 00        		.byte	0
 856 000d 01        		.byte	1
 857 000e 03        		.byte	3
 858 000f 00        		.byte	0
 859 0010 00        		.byte	0
 860 0011 00        		.byte	0
 861 0012 09        		.byte	9
 862 0013 21        		.byte	33
 863 0014 01        		.byte	1
 864 0015 01        		.byte	1
 865 0016 00        		.byte	0
 866 0017 01        		.byte	1
 867 0018 22        		.byte	34
 868 0019 34        		.byte	52
 869 001a 00        		.byte	0
 870 001b 07        		.byte	7
 871 001c 05        		.byte	5
 872 001d 81        		.byte	-127
 873 001e 03        		.byte	3
 874 001f 08        		.byte	8
 875 0020 00        		.byte	0
GAS LISTING /tmp/ccTUJtEn.s 			page 29


 876 0021 64        		.byte	100
 877               	.global	usbDescriptorDevice
 878               		.type	usbDescriptorDevice, @object
 879               		.size	usbDescriptorDevice, 18
 880               	usbDescriptorDevice:
 881 0022 12        		.byte	18
 882 0023 01        		.byte	1
 883 0024 10        		.byte	16
 884 0025 01        		.byte	1
 885 0026 00        		.byte	0
 886 0027 00        		.byte	0
 887 0028 00        		.byte	0
 888 0029 08        		.byte	8
 889 002a C0        		.byte	-64
 890 002b 16        		.byte	22
 891 002c E8        		.byte	-24
 892 002d 03        		.byte	3
 893 002e 00        		.byte	0
 894 002f 01        		.byte	1
 895 0030 01        		.byte	1
 896 0031 02        		.byte	2
 897 0032 00        		.byte	0
 898 0033 01        		.byte	1
 899               	.global	usbDescriptorStringDevice
 900               		.type	usbDescriptorStringDevice, @object
 901               		.size	usbDescriptorStringDevice, 12
 902               	usbDescriptorStringDevice:
 903 0034 0C03      		.word	780
 904 0036 4D00      		.word	77
 905 0038 6F00      		.word	111
 906 003a 7500      		.word	117
 907 003c 7300      		.word	115
 908 003e 6500      		.word	101
 909               	.global	usbDescriptorStringVendor
 910               		.type	usbDescriptorStringVendor, @object
 911               		.size	usbDescriptorStringVendor, 18
 912               	usbDescriptorStringVendor:
 913 0040 1203      		.word	786
 914 0042 6F00      		.word	111
 915 0044 6200      		.word	98
 916 0046 6400      		.word	100
 917 0048 6500      		.word	101
 918 004a 7600      		.word	118
 919 004c 2E00      		.word	46
 920 004e 6100      		.word	97
 921 0050 7400      		.word	116
 922               	.global	usbDescriptorString0
 923               		.type	usbDescriptorString0, @object
 924               		.size	usbDescriptorString0, 4
 925               	usbDescriptorString0:
 926 0052 04        		.byte	4
 927 0053 03        		.byte	3
 928 0054 09        		.byte	9
 929 0055 04        		.byte	4
 930               		.comm	usbMsgPtr,2,1
 931               		.comm	usbTxStatus1,12,1
 932               		.comm	usbTxBuf,11,1
GAS LISTING /tmp/ccTUJtEn.s 			page 30


 933               	.global	usbTxLen
 934               		.data
 935               		.type	usbTxLen, @object
 936               		.size	usbTxLen, 1
 937               	usbTxLen:
 938 0000 5A        		.byte	90
 939               		.comm	usbRxToken,1,1
 940               		.comm	usbCurrentTok,1,1
 941               		.comm	usbRxLen,1,1
 942               		.comm	usbConfiguration,1,1
 943               		.comm	usbNewDeviceAddr,1,1
 944               		.comm	usbDeviceAddr,1,1
 945               		.comm	usbInputBufOffset,1,1
 946               		.comm	usbRxBuf,22,1
 947               		.type	usbMsgLen, @object
 948               		.size	usbMsgLen, 1
 949               	usbMsgLen:
 950 0001 FF        		.byte	-1
 951               		.local	usbMsgFlags
 952               		.comm	usbMsgFlags,1,1
 953               		.stabs	"usbMsgLen:S(0,11)",38,0,49,usbMsgLen
 954               		.stabs	"usbMsgFlags:S(0,11)",40,0,50,usbMsgFlags
 955               		.stabs	"usbMsgPtr:G(0,16)",32,0,48,0
 956               		.stabs	"usbRxToken:G(0,11)",32,0,31,0
 957               		.stabs	"usbConfiguration:G(0,11)",32,0,28,0
 958               		.stabs	"usbDescriptorDevice:G(0,17)=ar(10,4);0;17;(0,18)=k(0,2)",32,0,111,0
 959               		.stabs	"usbDescriptorConfiguration:G(0,19)=ar(10,4);0;33;(0,18)",32,0,142,0
 960               		.stabs	"usbDescriptorString0:G(0,20)=ar(10,4);0;3;(0,18)",32,0,70,0
 961               		.stabs	"usbDescriptorStringVendor:G(0,21)=ar(10,4);0;8;(0,22)=k(0,1)",32,0,80,0
 962               		.stabs	"usbDescriptorStringDevice:G(0,23)=ar(10,4);0;5;(0,22)",32,0,89,0
 963               		.stabs	"usbTxStatus1:G(10,5)",32,0,38,0
 964               		.stabs	"usbRxBuf:G(0,24)=ar(10,4);0;21;(0,11)",32,0,24,0
 965               		.stabs	"usbInputBufOffset:G(0,11)",32,0,25,0
 966               		.stabs	"usbDeviceAddr:G(0,11)",32,0,26,0
 967               		.stabs	"usbNewDeviceAddr:G(0,11)",32,0,27,0
 968               		.stabs	"usbRxLen:G(0,25)=B(0,10)",32,0,29,0
 969               		.stabs	"usbCurrentTok:G(0,11)",32,0,30,0
 970               		.stabs	"usbTxLen:G(10,2)",32,0,32,0
 971               		.stabs	"usbTxBuf:G(10,3)",32,0,33,0
 972               		.text
 973               		.stabs	"",100,0,0,.Letext0
 974               	.Letext0:
 975               		.ident	"GCC: (GNU) 4.7.1"
 976               	.global __do_copy_data
 977               	.global __do_clear_bss
GAS LISTING /tmp/ccTUJtEn.s 			page 31


DEFINED SYMBOLS
                            *ABS*:0000000000000000 usbdrv.c
     /tmp/ccTUJtEn.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccTUJtEn.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccTUJtEn.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccTUJtEn.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccTUJtEn.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccTUJtEn.s:89     .text:0000000000000000 usbSetInterrupt
                            *COM*:000000000000000c usbTxStatus1
     /tmp/ccTUJtEn.s:176    .text:0000000000000044 usbPoll
                            *COM*:0000000000000001 usbRxLen
                            *COM*:0000000000000001 usbInputBufOffset
                            *COM*:0000000000000001 usbRxToken
     /tmp/ccTUJtEn.s:937    .data:0000000000000000 usbTxLen
     /tmp/ccTUJtEn.s:949    .data:0000000000000001 usbMsgLen
                            *COM*:000000000000000b usbTxBuf
                            *COM*:0000000000000002 usbMsgPtr
                             .bss:0000000000000000 usbMsgFlags
                            *COM*:0000000000000001 usbNewDeviceAddr
                            *COM*:0000000000000001 usbDeviceAddr
                            *COM*:0000000000000016 usbRxBuf
                            *COM*:0000000000000001 usbConfiguration
     /tmp/ccTUJtEn.s:880    .progmem.data:0000000000000022 usbDescriptorDevice
     /tmp/ccTUJtEn.s:842    .progmem.data:0000000000000000 usbDescriptorConfiguration
     /tmp/ccTUJtEn.s:925    .progmem.data:0000000000000052 usbDescriptorString0
     /tmp/ccTUJtEn.s:902    .progmem.data:0000000000000034 usbDescriptorStringDevice
     /tmp/ccTUJtEn.s:912    .progmem.data:0000000000000040 usbDescriptorStringVendor
     /tmp/ccTUJtEn.s:802    .text:00000000000002a4 usbInit
                            *COM*:0000000000000001 usbCurrentTok

UNDEFINED SYMBOLS
usbCrc16Append
usbFunctionSetup
usbDescriptorHidReport
__do_copy_data
__do_clear_bss
