GAS LISTING /tmp/ccWbVCMv.s 			page 1


   1               	# 1 "../lib/usbdrv/usbdrvasm.S"
   1               	/* Name: usbdrvasm.S
   0               	
   2               	 * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   3               	 * Author: Christian Starkjohann
   4               	 * Creation Date: 2007-06-13
   5               	 * Tabsize: 4
   6               	 * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
   7               	 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
   8               	 * Revision: $Id$
   9               	 */
  10               	
  11               	/*
  12               	General Description:
  13               	This module is the assembler part of the USB driver. This file contains
  14               	general code (preprocessor acrobatics and CRC computation) and then includes
  15               	the file appropriate for the given clock rate.
  16               	*/
  17               	
  18               	#define __SFR_OFFSET 0      /* used by avr-libc's register definitions */
  19               	#include "usbportability.h"
   1               	/* Name: usbportability.h
   2               	 * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   3               	 * Author: Christian Starkjohann
   4               	 * Creation Date: 2008-06-17
   5               	 * Tabsize: 4
   6               	 * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
   7               	 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
   8               	 * This Revision: $Id$
   9               	 */
  10               	
  11               	/*
  12               	General Description:
  13               	This header is intended to contain all (or at least most of) the compiler
  14               	and library dependent stuff. The C code is written for avr-gcc and avr-libc.
  15               	The API of other development environments is converted to gcc's and avr-libc's
  16               	API by means of defines.
  17               	
  18               	This header also contains all system includes since they depend on the
  19               	development environment.
  20               	
  21               	Thanks to Oleg Semyonov for his help with the IAR tools port!
  22               	*/
  23               	
  24               	#ifndef __usbportability_h_INCLUDED__
  25               	#define __usbportability_h_INCLUDED__
  26               	
  27               	/* We check explicitly for IAR and CodeVision. Default is avr-gcc/avr-libc. */
  28               	
  29               	/* ------------------------------------------------------------------------- */
  30               	#if defined __IAR_SYSTEMS_ICC__ || defined __IAR_SYSTEMS_ASM__  /* check for IAR */
  31               	/* ------------------------------------------------------------------------- */
  32               	
  33               	#ifndef ENABLE_BIT_DEFINITIONS
  34               	#   define ENABLE_BIT_DEFINITIONS	1   /* Enable bit definitions */
  35               	#endif
  36               	
GAS LISTING /tmp/ccWbVCMv.s 			page 2


  37               	/* Include IAR headers */
  38               	#include <ioavr.h>
  39               	#ifndef __IAR_SYSTEMS_ASM__
  40               	#   include <inavr.h>
  41               	#endif
  42               	
  43               	#define __attribute__(arg)  /* not supported on IAR */
  44               	
  45               	#ifdef __IAR_SYSTEMS_ASM__
  46               	#   define __ASSEMBLER__    /* IAR does not define standard macro for asm */
  47               	#endif
  48               	
  49               	#ifdef __HAS_ELPM__
  50               	#   define PROGMEM __farflash
  51               	#else
  52               	#   define PROGMEM __flash
  53               	#endif
  54               	
  55               	#define USB_READ_FLASH(addr)    (*(PROGMEM char *)(addr))
  56               	
  57               	/* The following definitions are not needed by the driver, but may be of some
  58               	 * help if you port a gcc based project to IAR.
  59               	 */
  60               	#define cli()       __disable_interrupt()
  61               	#define sei()       __enable_interrupt()
  62               	#define wdt_reset() __watchdog_reset()
  63               	#define _BV(x)      (1 << (x))
  64               	
  65               	/* assembler compatibility macros */
  66               	#define nop2    rjmp    $+2 /* jump to next instruction */
  67               	#define XL      r26
  68               	#define XH      r27
  69               	#define YL      r28
  70               	#define YH      r29
  71               	#define ZL      r30
  72               	#define ZH      r31
  73               	#define lo8(x)  LOW(x)
  74               	#define hi8(x)  (((x)>>8) & 0xff)   /* not HIGH to allow XLINK to make a proper range check */
  75               	
  76               	/* Depending on the device you use, you may get problems with the way usbdrv.h
  77               	 * handles the differences between devices. Since IAR does not use #defines
  78               	 * for MCU registers, we can't check for the existence of a particular
  79               	 * register with an #ifdef. If the autodetection mechanism fails, include
  80               	 * definitions for the required USB_INTR_* macros in your usbconfig.h. See
  81               	 * usbconfig-prototype.h and usbdrv.h for details.
  82               	 */
  83               	
  84               	/* ------------------------------------------------------------------------- */
  85               	#elif __CODEVISIONAVR__ /* check for CodeVision AVR */
  86               	/* ------------------------------------------------------------------------- */
  87               	/* This port is not working (yet) */
  88               	
  89               	/* #define F_CPU   _MCU_CLOCK_FREQUENCY_    seems to be defined automatically */
  90               	
  91               	#include <io.h>
  92               	#include <delay.h>
  93               	
GAS LISTING /tmp/ccWbVCMv.s 			page 3


  94               	#define __attribute__(arg)  /* not supported on IAR */
  95               	
  96               	#define PROGMEM                 __flash
  97               	#define USB_READ_FLASH(addr)    (*(PROGMEM char *)(addr))
  98               	
  99               	#ifndef __ASSEMBLER__
 100               	static inline void  cli(void)
 101               	{
 102               	    #asm("cli");
 103               	}
 104               	static inline void  sei(void)
 105               	{
 106               	    #asm("sei");
 107               	}
 108               	#endif
 109               	#define _delay_ms(t)    delay_ms(t)
 110               	#define _BV(x)          (1 << (x))
 111               	#define USB_CFG_USE_SWITCH_STATEMENT 1  /* macro for if() cascase fails for unknown reason */
 112               	
 113               	#define macro   .macro
 114               	#define endm    .endmacro
 115               	#define nop2    rjmp    .+0 /* jump to next instruction */
 116               	
 117               	/* ------------------------------------------------------------------------- */
 118               	#else   /* default development environment is avr-gcc/avr-libc */
 119               	/* ------------------------------------------------------------------------- */
 120               	
 121               	#include <avr/io.h>
   1               	/* Copyright (c) 2002,2003,2005,2006,2007 Marek Michalkiewicz, Joerg Wunsch
   2               	   Copyright (c) 2007 Eric B. Weddington
   3               	   All rights reserved.
   4               	
   5               	   Redistribution and use in source and binary forms, with or without
   6               	   modification, are permitted provided that the following conditions are met:
   7               	
   8               	   * Redistributions of source code must retain the above copyright
   9               	     notice, this list of conditions and the following disclaimer.
  10               	
  11               	   * Redistributions in binary form must reproduce the above copyright
  12               	     notice, this list of conditions and the following disclaimer in
  13               	     the documentation and/or other materials provided with the
  14               	     distribution.
  15               	
  16               	   * Neither the name of the copyright holders nor the names of
  17               	     contributors may be used to endorse or promote products derived
  18               	     from this software without specific prior written permission.
  19               	
  20               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
GAS LISTING /tmp/ccWbVCMv.s 			page 4


  30               	  POSSIBILITY OF SUCH DAMAGE. */
  31               	
  32               	/* $Id: io.h 2211 2011-02-14 14:04:25Z aboyapati $ */
  33               	
  34               	/** \file */
  35               	/** \defgroup avr_io <avr/io.h>: AVR device-specific IO definitions
  36               	    \code #include <avr/io.h> \endcode
  37               	
  38               	    This header file includes the apropriate IO definitions for the
  39               	    device that has been specified by the <tt>-mmcu=</tt> compiler
  40               	    command-line switch.  This is done by diverting to the appropriate
  41               	    file <tt>&lt;avr/io</tt><em>XXXX</em><tt>.h&gt;</tt> which should
  42               	    never be included directly.  Some register names common to all
  43               	    AVR devices are defined directly within <tt>&lt;avr/common.h&gt;</tt>,
  44               	    which is included in <tt>&lt;avr/io.h&gt;</tt>,
  45               	    but most of the details come from the respective include file.
  46               	
  47               	    Note that this file always includes the following files:
  48               	    \code 
  49               	    #include <avr/sfr_defs.h>
  50               	    #include <avr/portpins.h>
  51               	    #include <avr/common.h>
  52               	    #include <avr/version.h>
  53               	    \endcode
  54               	    See \ref avr_sfr for more details about that header file.
  55               	
  56               	    Included are definitions of the IO register set and their
  57               	    respective bit values as specified in the Atmel documentation.
  58               	    Note that inconsistencies in naming conventions,
  59               	    so even identical functions sometimes get different names on
  60               	    different devices.
  61               	
  62               	    Also included are the specific names useable for interrupt
  63               	    function definitions as documented
  64               	    \ref avr_signames "here".
  65               	
  66               	    Finally, the following macros are defined:
  67               	
  68               	    - \b RAMEND
  69               	    <br>
  70               	    The last on-chip RAM address.
  71               	    <br>
  72               	    - \b XRAMEND
  73               	    <br>
  74               	    The last possible RAM location that is addressable. This is equal to 
  75               	    RAMEND for devices that do not allow for external RAM. For devices 
  76               	    that allow external RAM, this will be larger than RAMEND.
  77               	    <br>
  78               	    - \b E2END
  79               	    <br>
  80               	    The last EEPROM address.
  81               	    <br>
  82               	    - \b FLASHEND
  83               	    <br>
  84               	    The last byte address in the Flash program space.
  85               	    <br>
  86               	    - \b SPM_PAGESIZE
GAS LISTING /tmp/ccWbVCMv.s 			page 5


  87               	    <br>
  88               	    For devices with bootloader support, the flash pagesize
  89               	    (in bytes) to be used for the \c SPM instruction. 
  90               	    - \b E2PAGESIZE
  91               	    <br>
  92               	    The size of the EEPROM page.
  93               	    
  94               	*/
  95               	
  96               	#ifndef _AVR_IO_H_
  97               	#define _AVR_IO_H_
  98               	
  99               	#include <avr/sfr_defs.h>
   1               	/* Copyright (c) 2002, Marek Michalkiewicz <marekm@amelek.gda.pl>
 100               	
 101               	#if defined (__AVR_AT94K__)
 102               	#  include <avr/ioat94k.h>
 103               	#elif defined (__AVR_AT43USB320__)
 104               	#  include <avr/io43u32x.h>
 105               	#elif defined (__AVR_AT43USB355__)
 106               	#  include <avr/io43u35x.h>
 107               	#elif defined (__AVR_AT76C711__)
 108               	#  include <avr/io76c711.h>
 109               	#elif defined (__AVR_AT86RF401__)
 110               	#  include <avr/io86r401.h>
 111               	#elif defined (__AVR_AT90PWM1__)
 112               	#  include <avr/io90pwm1.h>
 113               	#elif defined (__AVR_AT90PWM2__)
 114               	#  include <avr/io90pwmx.h>
 115               	#elif defined (__AVR_AT90PWM2B__)
 116               	#  include <avr/io90pwm2b.h>
 117               	#elif defined (__AVR_AT90PWM3__)
 118               	#  include <avr/io90pwmx.h>
 119               	#elif defined (__AVR_AT90PWM3B__)
 120               	#  include <avr/io90pwm3b.h>
 121               	#elif defined (__AVR_AT90PWM216__)
 122               	#  include <avr/io90pwm216.h>
 123               	#elif defined (__AVR_AT90PWM316__)
 124               	#  include <avr/io90pwm316.h>
 125               	#elif defined (__AVR_AT90PWM81__)
 126               	#  include <avr/io90pwm81.h>
 127               	#elif defined (__AVR_ATmega8U2__)
 128               	#  include <avr/iom8u2.h>
 129               	#elif defined (__AVR_ATmega16M1__)
 130               	#  include <avr/iom16m1.h>
 131               	#elif defined (__AVR_ATmega16U2__)
 132               	#  include <avr/iom16u2.h>
 133               	#elif defined (__AVR_ATmega16U4__)
 134               	#  include <avr/iom16u4.h>
 135               	#elif defined (__AVR_ATmega32C1__)
 136               	#  include <avr/iom32c1.h>
 137               	#elif defined (__AVR_ATmega32M1__)
 138               	#  include <avr/iom32m1.h>
 139               	#elif defined (__AVR_ATmega32U2__)
 140               	#  include <avr/iom32u2.h>
 141               	#elif defined (__AVR_ATmega32U4__)
 142               	#  include <avr/iom32u4.h>
GAS LISTING /tmp/ccWbVCMv.s 			page 6


 143               	#elif defined (__AVR_ATmega32U6__)
 144               	#  include <avr/iom32u6.h>
 145               	#elif defined (__AVR_ATmega64C1__)
 146               	#  include <avr/iom64c1.h>
 147               	#elif defined (__AVR_ATmega64M1__)
 148               	#  include <avr/iom64m1.h>
 149               	#elif defined (__AVR_ATmega128__)
 150               	#  include <avr/iom128.h>
 151               	#elif defined (__AVR_ATmega1280__)
 152               	#  include <avr/iom1280.h>
 153               	#elif defined (__AVR_ATmega1281__)
 154               	#  include <avr/iom1281.h>
 155               	#elif defined (__AVR_ATmega1284P__)
 156               	#  include <avr/iom1284p.h>
 157               	#elif defined (__AVR_ATmega128RFA1__)
 158               	#  include <avr/iom128rfa1.h>
 159               	#elif defined (__AVR_ATmega2560__)
 160               	#  include <avr/iom2560.h>
 161               	#elif defined (__AVR_ATmega2561__)
 162               	#  include <avr/iom2561.h>
 163               	#elif defined (__AVR_AT90CAN32__)
 164               	#  include <avr/iocan32.h>
 165               	#elif defined (__AVR_AT90CAN64__)
 166               	#  include <avr/iocan64.h>
 167               	#elif defined (__AVR_AT90CAN128__)
 168               	#  include <avr/iocan128.h>
 169               	#elif defined (__AVR_AT90USB82__)
 170               	#  include <avr/iousb82.h>
 171               	#elif defined (__AVR_AT90USB162__)
 172               	#  include <avr/iousb162.h>
 173               	#elif defined (__AVR_AT90USB646__)
 174               	#  include <avr/iousb646.h>
 175               	#elif defined (__AVR_AT90USB647__)
 176               	#  include <avr/iousb647.h>
 177               	#elif defined (__AVR_AT90USB1286__)
 178               	#  include <avr/iousb1286.h>
 179               	#elif defined (__AVR_AT90USB1287__)
 180               	#  include <avr/iousb1287.h>
 181               	#elif defined (__AVR_ATmega64__)
 182               	#  include <avr/iom64.h>
 183               	#elif defined (__AVR_ATmega640__)
 184               	#  include <avr/iom640.h>
 185               	#elif defined (__AVR_ATmega644__) || defined (__AVR_ATmega644A__)
 186               	#  include <avr/iom644.h>
 187               	#elif defined (__AVR_ATmega644P__)
 188               	#  include <avr/iom644p.h>
 189               	#elif defined (__AVR_ATmega644PA__)
 190               	#  include <avr/iom644pa.h>
 191               	#elif defined (__AVR_ATmega645__) || defined (__AVR_ATmega645A__) || defined (__AVR_ATmega645P__)
 192               	#  include <avr/iom645.h>
 193               	#elif defined (__AVR_ATmega6450__) || defined (__AVR_ATmega6450A__) || defined (__AVR_ATmega6450P__
 194               	#  include <avr/iom6450.h>
 195               	#elif defined (__AVR_ATmega649__) || defined (__AVR_ATmega649A__)
 196               	#  include <avr/iom649.h>
 197               	#elif defined (__AVR_ATmega6490__) || defined (__AVR_ATmega6490A__) || defined (__AVR_ATmega6490P__
 198               	#  include <avr/iom6490.h>
 199               	#elif defined (__AVR_ATmega649P__)
GAS LISTING /tmp/ccWbVCMv.s 			page 7


 200               	#  include <avr/iom649p.h>
 201               	#elif defined (__AVR_ATmega64HVE__)
 202               	#  include <avr/iom64hve.h>
 203               	#elif defined (__AVR_ATmega103__)
 204               	#  include <avr/iom103.h>
 205               	#elif defined (__AVR_ATmega32__)
 206               	#  include <avr/iom32.h>
 207               	#elif defined (__AVR_ATmega323__)
 208               	#  include <avr/iom323.h>
 209               	#elif defined (__AVR_ATmega324P__) || defined (__AVR_ATmega324A__)
 210               	#  include <avr/iom324.h>
 211               	#elif defined (__AVR_ATmega324PA__)
 212               	#  include <avr/iom324pa.h>
 213               	#elif defined (__AVR_ATmega325__) || defined (__AVR_ATmega325A__)
 214               	#  include <avr/iom325.h>
 215               	#elif defined (__AVR_ATmega325P__)
 216               	#  include <avr/iom325.h>
 217               	#elif defined (__AVR_ATmega3250__) || defined (__AVR_ATmega3250A__)
 218               	#  include <avr/iom3250.h>
 219               	#elif defined (__AVR_ATmega3250P__)
 220               	#  include <avr/iom3250.h>
 221               	#elif defined (__AVR_ATmega328P__) || defined (__AVR_ATmega328__)
 222               	#  include <avr/iom328p.h>
 223               	#elif defined (__AVR_ATmega329__) || defined (__AVR_ATmega329A__)
 224               	#  include <avr/iom329.h>
 225               	#elif defined (__AVR_ATmega329P__) || defined (__AVR_ATmega329PA__)
 226               	#  include <avr/iom329.h>
 227               	#elif defined (__AVR_ATmega3290__) || defined (__AVR_ATmega3290A__)
 228               	#  include <avr/iom3290.h>
 229               	#elif defined (__AVR_ATmega3290P__)
 230               	#  include <avr/iom3290.h>
 231               	#elif defined (__AVR_ATmega32HVB__)
 232               	#  include <avr/iom32hvb.h>
 233               	#elif defined (__AVR_ATmega32HVBREVB__)
 234               	#  include <avr/iom32hvbrevb.h>
 235               	#elif defined (__AVR_ATmega406__)
 236               	#  include <avr/iom406.h>
 237               	#elif defined (__AVR_ATmega16__)
 238               	#  include <avr/iom16.h>
 239               	#elif defined (__AVR_ATmega16A__)
 240               	#  include <avr/iom16a.h>
 241               	#elif defined (__AVR_ATmega161__)
 242               	#  include <avr/iom161.h>
 243               	#elif defined (__AVR_ATmega162__)
 244               	#  include <avr/iom162.h>
 245               	#elif defined (__AVR_ATmega163__)
 246               	#  include <avr/iom163.h>
 247               	#elif defined (__AVR_ATmega164P__) || defined (__AVR_ATmega164A__)
 248               	#  include <avr/iom164.h>
 249               	#elif defined (__AVR_ATmega165__) || defined (__AVR_ATmega165A__)
 250               	#  include <avr/iom165.h>
 251               	#elif defined (__AVR_ATmega165P__)
 252               	#  include <avr/iom165p.h>
 253               	#elif defined (__AVR_ATmega168__) || defined (__AVR_ATmega168A__)
 254               	#  include <avr/iom168.h>
   1               	/* Copyright (c) 2004, Theodore A. Roth
   2               	   All rights reserved.
GAS LISTING /tmp/ccWbVCMv.s 			page 8


   3               	
   4               	   Redistribution and use in source and binary forms, with or without
   5               	   modification, are permitted provided that the following conditions are met:
   6               	
   7               	   * Redistributions of source code must retain the above copyright
   8               	     notice, this list of conditions and the following disclaimer.
   9               	
  10               	   * Redistributions in binary form must reproduce the above copyright
  11               	     notice, this list of conditions and the following disclaimer in
  12               	     the documentation and/or other materials provided with the
  13               	     distribution.
  14               	
  15               	   * Neither the name of the copyright holders nor the names of
  16               	     contributors may be used to endorse or promote products derived
  17               	     from this software without specific prior written permission.
  18               	
  19               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29               	  POSSIBILITY OF SUCH DAMAGE. */
  30               	
  31               	/* $Id: iom168.h 2115 2010-04-05 23:19:53Z arcanum $ */
  32               	
  33               	#ifndef _AVR_IOM168_H_
  34               	#define _AVR_IOM168_H_ 1
  35               	
  36               	#include <avr/iomx8.h>
   1               	/* Copyright (c) 2004,2005, Theodore A. Roth
   2               	   All rights reserved.
   3               	
   4               	   Redistribution and use in source and binary forms, with or without
   5               	   modification, are permitted provided that the following conditions are met:
   6               	
   7               	   * Redistributions of source code must retain the above copyright
   8               	     notice, this list of conditions and the following disclaimer.
   9               	
  10               	   * Redistributions in binary form must reproduce the above copyright
  11               	     notice, this list of conditions and the following disclaimer in
  12               	     the documentation and/or other materials provided with the
  13               	     distribution.
  14               	
  15               	   * Neither the name of the copyright holders nor the names of
  16               	     contributors may be used to endorse or promote products derived
  17               	     from this software without specific prior written permission.
  18               	
  19               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
GAS LISTING /tmp/ccWbVCMv.s 			page 9


  24               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29               	  POSSIBILITY OF SUCH DAMAGE. */
  30               	
  31               	/* $Id: iomx8.h 2235 2011-03-17 04:13:14Z arcanum $ */
  32               	
  33               	/* avr/iomx8.h - definitions for ATmega48, ATmega88 and ATmega168 */
  34               	
  35               	#ifndef _AVR_IOMX8_H_
  36               	#define _AVR_IOMX8_H_ 1
  37               	
  38               	/* This file should only be included from <avr/io.h>, never directly. */
  39               	
  40               	#ifndef _AVR_IO_H_
  41               	#  error "Include <avr/io.h> instead of this file."
  42               	#endif
  43               	
  44               	#ifndef _AVR_IOXXX_H_
  45               	#  define _AVR_IOXXX_H_ "iomx8.h"
  46               	#else
  47               	#  error "Attempt to include more than one <avr/ioXXX.h> file."
  48               	#endif 
  49               	
  50               	/* I/O registers */
  51               	
  52               	/* Port B */
  53               	
  54               	#define PINB    _SFR_IO8 (0x03)
  55               	/* PINB */
  56               	#define PINB7   7
  57               	#define PINB6   6
  58               	#define PINB5   5
  59               	#define PINB4   4
  60               	#define PINB3   3
  61               	#define PINB2   2
  62               	#define PINB1   1
  63               	#define PINB0   0
  64               	
  65               	#define DDRB    _SFR_IO8 (0x04)
  66               	/* DDRB */
  67               	#define DDB7    7
  68               	#define DDB6    6
  69               	#define DDB5    5
  70               	#define DDB4    4
  71               	#define DDB3    3
  72               	#define DDB2    2
  73               	#define DDB1    1
  74               	#define DDB0    0
  75               	
  76               	#define PORTB   _SFR_IO8 (0x05)
  77               	/* PORTB */
  78               	#define PB7     7
  79               	#define PB6     6
  80               	#define PB5     5
GAS LISTING /tmp/ccWbVCMv.s 			page 10


  81               	#define PB4     4
  82               	#define PB3     3
  83               	#define PB2     2
  84               	#define PB1     1
  85               	#define PB0     0
  86               	
  87               	/* Port C */
  88               	
  89               	#define PINC    _SFR_IO8 (0x06)
  90               	/* PINC */
  91               	#define PINC6   6
  92               	#define PINC5   5
  93               	#define PINC4   4
  94               	#define PINC3   3
  95               	#define PINC2   2
  96               	#define PINC1   1
  97               	#define PINC0   0
  98               	
  99               	#define DDRC    _SFR_IO8 (0x07)
 100               	/* DDRC */
 101               	#define DDC6    6
 102               	#define DDC5    5
 103               	#define DDC4    4
 104               	#define DDC3    3
 105               	#define DDC2    2
 106               	#define DDC1    1
 107               	#define DDC0    0
 108               	
 109               	#define PORTC   _SFR_IO8 (0x08)
 110               	/* PORTC */
 111               	#define PC6     6
 112               	#define PC5     5
 113               	#define PC4     4
 114               	#define PC3     3
 115               	#define PC2     2
 116               	#define PC1     1
 117               	#define PC0     0
 118               	
 119               	/* Port D */
 120               	
 121               	#define PIND    _SFR_IO8 (0x09)
 122               	/* PIND */
 123               	#define PIND7   7
 124               	#define PIND6   6
 125               	#define PIND5   5
 126               	#define PIND4   4
 127               	#define PIND3   3
 128               	#define PIND2   2
 129               	#define PIND1   1
 130               	#define PIND0   0
 131               	
 132               	#define DDRD    _SFR_IO8 (0x0A)
 133               	/* DDRD */
 134               	#define DDD7    7
 135               	#define DDD6    6
 136               	#define DDD5    5
 137               	#define DDD4    4
GAS LISTING /tmp/ccWbVCMv.s 			page 11


 138               	#define DDD3    3
 139               	#define DDD2    2
 140               	#define DDD1    1
 141               	#define DDD0    0
 142               	
 143               	#define PORTD   _SFR_IO8 (0x0B)
 144               	/* PORTD */
 145               	#define PD7     7
 146               	#define PD6     6
 147               	#define PD5     5
 148               	#define PD4     4
 149               	#define PD3     3
 150               	#define PD2     2
 151               	#define PD1     1
 152               	#define PD0     0
 153               	
 154               	#define TIFR0   _SFR_IO8 (0x15)
 155               	/* TIFR0 */
 156               	#define OCF0B   2
 157               	#define OCF0A   1
 158               	#define TOV0    0
 159               	
 160               	#define TIFR1   _SFR_IO8 (0x16)
 161               	/* TIFR1 */
 162               	#define ICF1    5
 163               	#define OCF1B   2
 164               	#define OCF1A   1
 165               	#define TOV1    0
 166               	
 167               	#define TIFR2   _SFR_IO8 (0x17)
 168               	/* TIFR2 */
 169               	#define OCF2B   2
 170               	#define OCF2A   1
 171               	#define TOV2    0
 172               	
 173               	#define PCIFR   _SFR_IO8 (0x1B)
 174               	/* PCIFR */
 175               	#define PCIF2   2
 176               	#define PCIF1   1
 177               	#define PCIF0   0
 178               	
 179               	#define EIFR    _SFR_IO8 (0x1C)
 180               	/* EIFR */
 181               	#define INTF1   1
 182               	#define INTF0   0
 183               	
 184               	#define EIMSK   _SFR_IO8 (0x1D)
 185               	/* EIMSK */
 186               	#define INT1    1
 187               	#define INT0    0
 188               	
 189               	#define GPIOR0  _SFR_IO8 (0x1E)
 190               	
 191               	#define EECR    _SFR_IO8(0x1F)
 192               	/* EECT - EEPROM Control Register */
 193               	#define EEPM1   5
 194               	#define EEPM0   4
GAS LISTING /tmp/ccWbVCMv.s 			page 12


 195               	#define EERIE   3
 196               	#define EEMPE   2
 197               	#define EEPE    1
 198               	#define EERE    0
 199               	
 200               	#define EEDR    _SFR_IO8(0X20)
 201               	
 202               	/* Combine EEARL and EEARH */
 203               	#define EEAR    _SFR_IO16(0x21)
 204               	#define EEARL   _SFR_IO8(0x21)
 205               	#define EEARH   _SFR_IO8(0X22)
 206               	/* 
 207               	Even though EEARH is not used by the mega48, the EEAR8 bit in the register
 208               	must be written to 0, according to the datasheet, hence the EEARH register
 209               	must be defined for the mega48.
 210               	*/
 211               	/* 6-char sequence denoting where to find the EEPROM registers in memory space.
 212               	   Adresses denoted in hex syntax with uppercase letters. Used by the EEPROM
 213               	   subroutines.
 214               	   First two letters:  EECR address.
 215               	   Second two letters: EEDR address.
 216               	   Last two letters:   EEAR address.  */
 217               	#define __EEPROM_REG_LOCATIONS__ 1F2021
 218               	
 219               	
 220               	#define GTCCR   _SFR_IO8 (0x23)
 221               	/* GTCCR */
 222               	#define TSM     7
 223               	#define PSRASY  1
 224               	#define PSRSYNC 0
 225               	
 226               	#define TCCR0A  _SFR_IO8 (0x24)
 227               	/* TCCR0A */
 228               	#define COM0A1  7
 229               	#define COM0A0  6
 230               	#define COM0B1  5
 231               	#define COM0B0  4
 232               	#define WGM01   1
 233               	#define WGM00   0
 234               	
 235               	#define TCCR0B  _SFR_IO8 (0x25)
 236               	/* TCCR0A */
 237               	#define FOC0A   7
 238               	#define FOC0B   6
 239               	#define WGM02   3
 240               	#define CS02    2
 241               	#define CS01    1
 242               	#define CS00    0
 243               	
 244               	#define TCNT0   _SFR_IO8 (0x26)
 245               	#define OCR0A   _SFR_IO8 (0x27)
 246               	#define OCR0B   _SFR_IO8 (0x28)
 247               	
 248               	#define GPIOR1  _SFR_IO8 (0x2A)
 249               	#define GPIOR2  _SFR_IO8 (0x2B)
 250               	
 251               	#define SPCR    _SFR_IO8 (0x2C)
GAS LISTING /tmp/ccWbVCMv.s 			page 13


 252               	/* SPCR */
 253               	#define SPIE    7
 254               	#define SPE     6
 255               	#define DORD    5
 256               	#define MSTR    4
 257               	#define CPOL    3
 258               	#define CPHA    2
 259               	#define SPR1    1
 260               	#define SPR0    0
 261               	
 262               	#define SPSR    _SFR_IO8 (0x2D)
 263               	/* SPSR */
 264               	#define SPIF    7
 265               	#define WCOL    6
 266               	#define SPI2X   0
 267               	
 268               	#define SPDR    _SFR_IO8 (0x2E)
 269               	
 270               	#define ACSR    _SFR_IO8 (0x30)
 271               	/* ACSR */
 272               	#define ACD     7
 273               	#define ACBG    6
 274               	#define ACO     5
 275               	#define ACI     4
 276               	#define ACIE    3
 277               	#define ACIC    2
 278               	#define ACIS1   1
 279               	#define ACIS0   0
 280               	
 281               	#define MONDR   _SFR_IO8 (0x31)
 282               	
 283               	#define SMCR    _SFR_IO8 (0x33)
 284               	/* SMCR */
 285               	#define SM2     3
 286               	#define SM1     2
 287               	#define SM0     1
 288               	#define SE      0
 289               	
 290               	#define MCUSR   _SFR_IO8 (0x34)
 291               	/* MCUSR */
 292               	#define WDRF    3
 293               	#define BORF    2
 294               	#define EXTRF   1
 295               	#define PORF    0
 296               	
 297               	#define MCUCR   _SFR_IO8 (0x35)
 298               	/* MCUCR */
 299               	#define PUD     4
 300               	#if defined (__AVR_ATmega88__) || defined (__AVR_ATmega168__) 
 301               	#define IVSEL   1
 302               	#define IVCE    0
 303               	#endif
 304               	
 305               	#define SPMCSR  _SFR_IO8 (0x37)
 306               	/* SPMCSR */
 307               	#define SPMIE     7
 308               	#if defined (__AVR_ATmega88__) || defined (__AVR_ATmega168__)
GAS LISTING /tmp/ccWbVCMv.s 			page 14


 309               	#  define RWWSB   6
 310               	#  define RWWSRE  4
 311               	#endif
 312               	#define BLBSET    3
 313               	#define PGWRT     2
 314               	#define PGERS     1
 315               	#define SELFPRGEN 0
 316               	#define SPMEN     0
 317               	
 318               	/* 0x3D..0x3E SP  [defined in <avr/io.h>] */
 319               	/* 0x3F SREG      [defined in <avr/io.h>] */
 320               	
 321               	#define WDTCSR  _SFR_MEM8 (0x60)
 322               	/* WDTCSR */
 323               	#define WDIF    7
 324               	#define WDIE    6
 325               	#define WDP3    5
 326               	#define WDCE    4
 327               	#define WDE     3
 328               	#define WDP2    2
 329               	#define WDP1    1
 330               	#define WDP0    0
 331               	
 332               	#define CLKPR   _SFR_MEM8 (0x61)
 333               	/* CLKPR */
 334               	#define CLKPCE  7
 335               	#define CLKPS3  3
 336               	#define CLKPS2  2
 337               	#define CLKPS1  1
 338               	#define CLKPS0  0
 339               	
 340               	#define PRR     _SFR_MEM8 (0x64)
 341               	/* PRR */
 342               	#define PRTWI    7
 343               	#define PRTIM2   6
 344               	#define PRTIM0   5
 345               	#define PRTIM1   3
 346               	#define PRSPI    2
 347               	#define PRUSART0 1
 348               	#define PRADC    0
 349               	
 350               	#define OSCCAL  _SFR_MEM8 (0x66)
 351               	
 352               	#define PCICR   _SFR_MEM8 (0x68)
 353               	/* PCICR */
 354               	#define PCIE2   2
 355               	#define PCIE1   1
 356               	#define PCIE0   0
 357               	
 358               	#define EICRA   _SFR_MEM8 (0x69)
 359               	/* EICRA */
 360               	#define ISC11   3
 361               	#define ISC10   2
 362               	#define ISC01   1
 363               	#define ISC00   0
 364               	
 365               	#define PCMSK0  _SFR_MEM8 (0x6B)
GAS LISTING /tmp/ccWbVCMv.s 			page 15


 366               	/* PCMSK0 */
 367               	#define PCINT7    7
 368               	#define PCINT6    6
 369               	#define PCINT5    5
 370               	#define PCINT4    4
 371               	#define PCINT3    3
 372               	#define PCINT2    2
 373               	#define PCINT1    1
 374               	#define PCINT0    0
 375               	
 376               	#define PCMSK1  _SFR_MEM8 (0x6C)
 377               	/* PCMSK1 */
 378               	#define PCINT14   6
 379               	#define PCINT13   5
 380               	#define PCINT12   4
 381               	#define PCINT11   3
 382               	#define PCINT10   2
 383               	#define PCINT9    1
 384               	#define PCINT8    0
 385               	
 386               	#define PCMSK2  _SFR_MEM8 (0x6D)
 387               	/* PCMSK2 */
 388               	#define PCINT23   7
 389               	#define PCINT22   6
 390               	#define PCINT21   5
 391               	#define PCINT20   4
 392               	#define PCINT19   3
 393               	#define PCINT18   2
 394               	#define PCINT17   1
 395               	#define PCINT16   0
 396               	
 397               	#define TIMSK0  _SFR_MEM8 (0x6E)
 398               	/* TIMSK0 */
 399               	#define OCIE0B  2
 400               	#define OCIE0A  1
 401               	#define TOIE0   0
 402               	
 403               	#define TIMSK1  _SFR_MEM8 (0x6F)
 404               	/* TIMSK1 */
 405               	#define ICIE1   5
 406               	#define OCIE1B  2
 407               	#define OCIE1A  1
 408               	#define TOIE1   0
 409               	
 410               	#define TIMSK2  _SFR_MEM8 (0x70)
 411               	/* TIMSK2 */
 412               	#define OCIE2B  2
 413               	#define OCIE2A  1
 414               	#define TOIE2   0
 415               	
 416               	#ifndef __ASSEMBLER__
 417               	#define ADC     _SFR_MEM16 (0x78)
 418               	#endif
 419               	#define ADCW    _SFR_MEM16 (0x78)
 420               	#define ADCL    _SFR_MEM8 (0x78)
 421               	#define ADCH    _SFR_MEM8 (0x79)
 422               	
GAS LISTING /tmp/ccWbVCMv.s 			page 16


 423               	#define ADCSRA  _SFR_MEM8 (0x7A)
 424               	/* ADCSRA */
 425               	#define ADEN    7
 426               	#define ADSC    6
 427               	#define ADATE   5
 428               	#define ADIF    4
 429               	#define ADIE    3
 430               	#define ADPS2   2
 431               	#define ADPS1   1
 432               	#define ADPS0   0
 433               	
 434               	#define ADCSRB  _SFR_MEM8 (0x7B)
 435               	/* ADCSRB */
 436               	#define ACME    6
 437               	#define ADTS2   2
 438               	#define ADTS1   1
 439               	#define ADTS0   0
 440               	
 441               	#define ADMUX   _SFR_MEM8 (0x7C)
 442               	/* ADMUX */
 443               	#define REFS1   7
 444               	#define REFS0   6
 445               	#define ADLAR   5
 446               	#define MUX3    3
 447               	#define MUX2    2
 448               	#define MUX1    1
 449               	#define MUX0    0
 450               	
 451               	#define DIDR0   _SFR_MEM8 (0x7E)
 452               	/* DIDR0 */
 453               	#define ADC5D   5
 454               	#define ADC4D   4
 455               	#define ADC3D   3
 456               	#define ADC2D   2
 457               	#define ADC1D   1
 458               	#define ADC0D   0
 459               	
 460               	#define DIDR1   _SFR_MEM8 (0x7F)
 461               	/* DIDR1 */
 462               	#define AIN1D   1
 463               	#define AIN0D   0
 464               	
 465               	#define TCCR1A  _SFR_MEM8 (0x80)
 466               	/* TCCR1A */
 467               	#define COM1A1  7
 468               	#define COM1A0  6
 469               	#define COM1B1  5
 470               	#define COM1B0  4
 471               	#define WGM11   1
 472               	#define WGM10   0
 473               	
 474               	#define TCCR1B  _SFR_MEM8 (0x81)
 475               	/* TCCR1B */
 476               	#define ICNC1   7
 477               	#define ICES1   6
 478               	#define WGM13   4
 479               	#define WGM12   3
GAS LISTING /tmp/ccWbVCMv.s 			page 17


 480               	#define CS12    2
 481               	#define CS11    1
 482               	#define CS10    0
 483               	
 484               	#define TCCR1C  _SFR_MEM8 (0x82)
 485               	/* TCCR1C */
 486               	#define FOC1A   7
 487               	#define FOC1B   6
 488               	
 489               	#define TCNT1   _SFR_MEM16 (0x84)
 490               	#define TCNT1L  _SFR_MEM8 (0x84)
 491               	#define TCNT1H  _SFR_MEM8 (0x85)
 492               	
 493               	#define ICR1    _SFR_MEM16 (0x86)
 494               	#define ICR1L   _SFR_MEM8 (0x86)
 495               	#define ICR1H   _SFR_MEM8 (0x87)
 496               	
 497               	#define OCR1A   _SFR_MEM16 (0x88)
 498               	#define OCR1AL  _SFR_MEM8 (0x88)
 499               	#define OCR1AH  _SFR_MEM8 (0x89)
 500               	
 501               	#define OCR1B   _SFR_MEM16 (0x8A)
 502               	#define OCR1BL  _SFR_MEM8 (0x8A)
 503               	#define OCR1BH  _SFR_MEM8 (0x8B)
 504               	
 505               	#define TCCR2A  _SFR_MEM8 (0xB0)
 506               	/* TCCR2A */
 507               	#define COM2A1  7
 508               	#define COM2A0  6
 509               	#define COM2B1  5
 510               	#define COM2B0  4
 511               	#define WGM21   1
 512               	#define WGM20   0
 513               	
 514               	#define TCCR2B  _SFR_MEM8 (0xB1)
 515               	/* TCCR2B */
 516               	#define FOC2A   7
 517               	#define FOC2B   6
 518               	#define WGM22   3
 519               	#define CS22    2
 520               	#define CS21    1
 521               	#define CS20    0
 522               	
 523               	#define TCNT2   _SFR_MEM8 (0xB2)
 524               	#define OCR2A   _SFR_MEM8 (0xB3)
 525               	#define OCR2B   _SFR_MEM8 (0xB4)
 526               	
 527               	#define ASSR    _SFR_MEM8 (0xB6)
 528               	/* ASSR */
 529               	#define EXCLK    6
 530               	#define AS2      5
 531               	#define TCN2UB   4
 532               	#define OCR2AUB  3
 533               	#define OCR2BUB  2
 534               	#define TCR2AUB  1
 535               	#define TCR2BUB  0
 536               	
GAS LISTING /tmp/ccWbVCMv.s 			page 18


 537               	#define TWBR    _SFR_MEM8 (0xB8)
 538               	
 539               	#define TWSR    _SFR_MEM8 (0xB9)
 540               	/* TWSR */
 541               	#define TWS7    7
 542               	#define TWS6    6
 543               	#define TWS5    5
 544               	#define TWS4    4
 545               	#define TWS3    3
 546               	#define TWPS1   1
 547               	#define TWPS0   0
 548               	
 549               	#define TWAR    _SFR_MEM8 (0xBA)
 550               	/* TWAR */
 551               	#define TWA6    7
 552               	#define TWA5    6
 553               	#define TWA4    5
 554               	#define TWA3    4
 555               	#define TWA2    3
 556               	#define TWA1    2
 557               	#define TWA0    1
 558               	#define TWGCE   0
 559               	
 560               	#define TWDR    _SFR_MEM8 (0xBB)
 561               	
 562               	#define TWCR    _SFR_MEM8 (0xBC)
 563               	/* TWCR */
 564               	#define TWINT   7
 565               	#define TWEA    6
 566               	#define TWSTA   5
 567               	#define TWSTO   4
 568               	#define TWWC    3
 569               	#define TWEN    2
 570               	#define TWIE    0
 571               	
 572               	#define TWAMR   _SFR_MEM8 (0xBD)
 573               	/* TWAMR */
 574               	#define TWAM6   7
 575               	#define TWAM5   6
 576               	#define TWAM4   5
 577               	#define TWAM3   4
 578               	#define TWAM2   3
 579               	#define TWAM1   2
 580               	#define TWAM0   1
 581               	
 582               	#define UCSR0A  _SFR_MEM8 (0xC0)
 583               	/* UCSR0A */
 584               	#define RXC0    7
 585               	#define TXC0    6
 586               	#define UDRE0   5
 587               	#define FE0     4
 588               	#define DOR0    3
 589               	#define UPE0    2
 590               	#define U2X0    1
 591               	#define MPCM0   0
 592               	
 593               	#define UCSR0B  _SFR_MEM8 (0xC1)
GAS LISTING /tmp/ccWbVCMv.s 			page 19


 594               	/* UCSR0B */
 595               	#define RXCIE0  7
 596               	#define TXCIE0  6
 597               	#define UDRIE0  5
 598               	#define RXEN0   4
 599               	#define TXEN0   3
 600               	#define UCSZ02  2
 601               	#define RXB80   1
 602               	#define TXB80   0
 603               	
 604               	#define UCSR0C  _SFR_MEM8 (0xC2)
 605               	/* UCSR0C */
 606               	#define UMSEL01  7
 607               	#define UMSEL00  6
 608               	#define UPM01    5
 609               	#define UPM00    4
 610               	#define USBS0    3
 611               	#define UCSZ01   2
 612               	#define UDORD0   2
 613               	#define UCSZ00   1
 614               	#define UCPHA0   1
 615               	#define UCPOL0   0
 616               	
 617               	#define UBRR0   _SFR_MEM16 (0xC4)
 618               	#define UBRR0L  _SFR_MEM8 (0xC4)
 619               	#define UBRR0H  _SFR_MEM8 (0xC5)
 620               	#define UDR0    _SFR_MEM8 (0xC6)
 621               	
 622               	/* Interrupt vectors */
 623               	
 624               	/* External Interrupt Request 0 */
 625               	#define INT0_vect_num		1
 626               	#define INT0_vect			_VECTOR(1)
 627               	#define SIG_INTERRUPT0			_VECTOR(1)
 628               	
 629               	/* External Interrupt Request 1 */
 630               	#define INT1_vect_num		2
 631               	#define INT1_vect			_VECTOR(2)
 632               	#define SIG_INTERRUPT1			_VECTOR(2)
 633               	
 634               	/* Pin Change Interrupt Request 0 */
 635               	#define PCINT0_vect_num		3
 636               	#define PCINT0_vect			_VECTOR(3)
 637               	#define SIG_PIN_CHANGE0			_VECTOR(3)
 638               	
 639               	/* Pin Change Interrupt Request 0 */
 640               	#define PCINT1_vect_num		4
 641               	#define PCINT1_vect			_VECTOR(4)
 642               	#define SIG_PIN_CHANGE1			_VECTOR(4)
 643               	
 644               	/* Pin Change Interrupt Request 1 */
 645               	#define PCINT2_vect_num		5
 646               	#define PCINT2_vect			_VECTOR(5)
 647               	#define SIG_PIN_CHANGE2			_VECTOR(5)
 648               	
 649               	/* Watchdog Time-out Interrupt */
 650               	#define WDT_vect_num		6
GAS LISTING /tmp/ccWbVCMv.s 			page 20


 651               	#define WDT_vect			_VECTOR(6)
 652               	#define SIG_WATCHDOG_TIMEOUT		_VECTOR(6)
 653               	
 654               	/* Timer/Counter2 Compare Match A */
 655               	#define TIMER2_COMPA_vect_num	7
 656               	#define TIMER2_COMPA_vect		_VECTOR(7)
 657               	#define SIG_OUTPUT_COMPARE2A		_VECTOR(7)
 658               	
 659               	/* Timer/Counter2 Compare Match A */
 660               	#define TIMER2_COMPB_vect_num	8
 661               	#define TIMER2_COMPB_vect		_VECTOR(8)
 662               	#define SIG_OUTPUT_COMPARE2B		_VECTOR(8)
 663               	
 664               	/* Timer/Counter2 Overflow */
 665               	#define TIMER2_OVF_vect_num		9
 666               	#define TIMER2_OVF_vect			_VECTOR(9)
 667               	#define SIG_OVERFLOW2			_VECTOR(9)
 668               	
 669               	/* Timer/Counter1 Capture Event */
 670               	#define TIMER1_CAPT_vect_num	10
 671               	#define TIMER1_CAPT_vect		_VECTOR(10)
 672               	#define SIG_INPUT_CAPTURE1		_VECTOR(10)
 673               	
 674               	/* Timer/Counter1 Compare Match A */
 675               	#define TIMER1_COMPA_vect_num	11
 676               	#define TIMER1_COMPA_vect		_VECTOR(11)
 677               	#define SIG_OUTPUT_COMPARE1A		_VECTOR(11)
 678               	
 679               	/* Timer/Counter1 Compare Match B */
 680               	#define TIMER1_COMPB_vect_num	12
 681               	#define TIMER1_COMPB_vect		_VECTOR(12)
 682               	#define SIG_OUTPUT_COMPARE1B		_VECTOR(12)
 683               	
 684               	/* Timer/Counter1 Overflow */
 685               	#define TIMER1_OVF_vect_num		13
 686               	#define TIMER1_OVF_vect			_VECTOR(13)
 687               	#define SIG_OVERFLOW1			_VECTOR(13)
 688               	
 689               	/* TimerCounter0 Compare Match A */
 690               	#define TIMER0_COMPA_vect_num	14
 691               	#define TIMER0_COMPA_vect		_VECTOR(14)
 692               	#define SIG_OUTPUT_COMPARE0A		_VECTOR(14)
 693               	
 694               	/* TimerCounter0 Compare Match B */
 695               	#define TIMER0_COMPB_vect_num	15
 696               	#define TIMER0_COMPB_vect		_VECTOR(15)
 697               	#define SIG_OUTPUT_COMPARE0B		_VECTOR(15)
 698               	
 699               	/* Timer/Couner0 Overflow */
 700               	#define TIMER0_OVF_vect_num		16
 701               	#define TIMER0_OVF_vect			_VECTOR(16)
 702               	#define SIG_OVERFLOW0			_VECTOR(16)
 703               	
 704               	/* SPI Serial Transfer Complete */
 705               	#define SPI_STC_vect_num		17
 706               	#define SPI_STC_vect			_VECTOR(17)
 707               	#define SIG_SPI				_VECTOR(17)
GAS LISTING /tmp/ccWbVCMv.s 			page 21


 708               	
 709               	/* USART Rx Complete */
 710               	#define USART_RX_vect_num		18
 711               	#define USART_RX_vect			_VECTOR(18)
 712               	#define SIG_USART_RECV			_VECTOR(18)
 713               	
 714               	/* USART, Data Register Empty */
 715               	#define USART_UDRE_vect_num		19
 716               	#define USART_UDRE_vect			_VECTOR(19)
 717               	#define SIG_USART_DATA			_VECTOR(19)
 718               	
 719               	/* USART Tx Complete */
 720               	#define USART_TX_vect_num		20
 721               	#define USART_TX_vect			_VECTOR(20)
 722               	#define SIG_USART_TRANS			_VECTOR(20)
 723               	
 724               	/* ADC Conversion Complete */
 725               	#define ADC_vect_num		21
 726               	#define ADC_vect			_VECTOR(21)
 727               	#define SIG_ADC				_VECTOR(21)
 728               	
 729               	/* EEPROM Ready */
 730               	#define EE_READY_vect_num		22
 731               	#define EE_READY_vect			_VECTOR(22)
 732               	#define SIG_EEPROM_READY		_VECTOR(22)
 733               	
 734               	/* Analog Comparator */
 735               	#define ANALOG_COMP_vect_num	23
 736               	#define ANALOG_COMP_vect		_VECTOR(23)
 737               	#define SIG_COMPARATOR			_VECTOR(23)
 738               	
 739               	/* Two-wire Serial Interface */
 740               	#define TWI_vect_num		24
 741               	#define TWI_vect			_VECTOR(24)
 742               	#define SIG_TWI				_VECTOR(24)
 743               	#define SIG_2WIRE_SERIAL		_VECTOR(24)
 744               	
 745               	/* Store Program Memory Read */
 746               	#define SPM_READY_vect_num		25
 747               	#define SPM_READY_vect			_VECTOR(25)
 748               	#define SIG_SPM_READY			_VECTOR(25)
 749               	
 750               	/* The mega48 and mega88 vector tables are single instruction entries (16 bits
 751               	   per entry for an RJMP) while the mega168 table has double instruction
 752               	   entries (32 bits per entry for a JMP). */
 753               	
 754               	#if defined (__AVR_ATmega168__) || defined (__AVR_ATmega168A__)
 755               	#  define _VECTORS_SIZE 104
 756               	#else
 757               	#  define _VECTORS_SIZE 52
 758               	#endif
 759               	
 760               	
 761               	/* Deprecated items */
 762               	#if !defined(__AVR_LIBC_DEPRECATED_ENABLE__)
 763               	
 764               	#pragma GCC system_header
GAS LISTING /tmp/ccWbVCMv.s 			page 22


 765               	
 766               	#pragma GCC poison SIG_INTERRUPT0
 767               	#pragma GCC poison SIG_INTERRUPT1
 768               	#pragma GCC poison SIG_PIN_CHANGE0
 769               	#pragma GCC poison SIG_PIN_CHANGE1
 770               	#pragma GCC poison SIG_PIN_CHANGE2
 771               	#pragma GCC poison SIG_WATCHDOG_TIMEOUT
 772               	#pragma GCC poison SIG_OUTPUT_COMPARE2A
 773               	#pragma GCC poison SIG_OUTPUT_COMPARE2B
 774               	#pragma GCC poison SIG_OVERFLOW2
 775               	#pragma GCC poison SIG_INPUT_CAPTURE1
 776               	#pragma GCC poison SIG_OUTPUT_COMPARE1A
 777               	#pragma GCC poison SIG_OUTPUT_COMPARE1B
 778               	#pragma GCC poison SIG_OVERFLOW1
 779               	#pragma GCC poison SIG_OUTPUT_COMPARE0A
 780               	#pragma GCC poison SIG_OUTPUT_COMPARE0B
 781               	#pragma GCC poison SIG_OVERFLOW0
 782               	#pragma GCC poison SIG_SPI
 783               	#pragma GCC poison SIG_USART_RECV
 784               	#pragma GCC poison SIG_USART_DATA
 785               	#pragma GCC poison SIG_USART_TRANS
 786               	#pragma GCC poison SIG_ADC
 787               	#pragma GCC poison SIG_EEPROM_READY
 788               	#pragma GCC poison SIG_COMPARATOR
 789               	#pragma GCC poison SIG_TWI
 790               	#pragma GCC poison SIG_2WIRE_SERIAL
 791               	#pragma GCC poison SIG_SPM_READY
 792               	
  37               	
 255               	#elif defined (__AVR_ATmega168P__)
 256               	#  include <avr/iom168p.h>
 257               	#elif defined (__AVR_ATmega169__) || defined (__AVR_ATmega169A__)
 258               	#  include <avr/iom169.h>
 259               	#elif defined (__AVR_ATmega169P__)
 260               	#  include <avr/iom169p.h>
 261               	#elif defined (__AVR_ATmega169PA__)
 262               	#  include <avr/iom169pa.h>
 263               	#elif defined (__AVR_ATmega8HVA__)
 264               	#  include <avr/iom8hva.h>
 265               	#elif defined (__AVR_ATmega16HVA__)
 266               	#  include <avr/iom16hva.h>
 267               	#elif defined (__AVR_ATmega16HVA2__)
 268               	#  include <avr/iom16hva2.h>
 269               	#elif defined (__AVR_ATmega16HVB__)
 270               	#  include <avr/iom16hvb.h>
 271               	#elif defined (__AVR_ATmega16HVBREVB__)
 272               	#  include <avr/iom16hvbrevb.h>
 273               	#elif defined (__AVR_ATmega8__)
 274               	#  include <avr/iom8.h>
 275               	#elif defined (__AVR_ATmega48__) || defined (__AVR_ATmega48A__)
 276               	#  include <avr/iom48.h>
 277               	#elif defined (__AVR_ATmega48P__)
 278               	#  include <avr/iom48p.h>
 279               	#elif defined (__AVR_ATmega88__) || defined (__AVR_ATmega88A__)
 280               	#  include <avr/iom88.h>
 281               	#elif defined (__AVR_ATmega88P__)
 282               	#  include <avr/iom88p.h>
GAS LISTING /tmp/ccWbVCMv.s 			page 23


 283               	#elif defined (__AVR_ATmega88PA__)
 284               	#  include <avr/iom88pa.h>
 285               	#elif defined (__AVR_ATmega8515__)
 286               	#  include <avr/iom8515.h>
 287               	#elif defined (__AVR_ATmega8535__)
 288               	#  include <avr/iom8535.h>
 289               	#elif defined (__AVR_AT90S8535__)
 290               	#  include <avr/io8535.h>
 291               	#elif defined (__AVR_AT90C8534__)
 292               	#  include <avr/io8534.h>
 293               	#elif defined (__AVR_AT90S8515__)
 294               	#  include <avr/io8515.h>
 295               	#elif defined (__AVR_AT90S4434__)
 296               	#  include <avr/io4434.h>
 297               	#elif defined (__AVR_AT90S4433__)
 298               	#  include <avr/io4433.h>
 299               	#elif defined (__AVR_AT90S4414__)
 300               	#  include <avr/io4414.h>
 301               	#elif defined (__AVR_ATtiny22__)
 302               	#  include <avr/iotn22.h>
 303               	#elif defined (__AVR_ATtiny26__)
 304               	#  include <avr/iotn26.h>
 305               	#elif defined (__AVR_AT90S2343__)
 306               	#  include <avr/io2343.h>
 307               	#elif defined (__AVR_AT90S2333__)
 308               	#  include <avr/io2333.h>
 309               	#elif defined (__AVR_AT90S2323__)
 310               	#  include <avr/io2323.h>
 311               	#elif defined (__AVR_AT90S2313__)
 312               	#  include <avr/io2313.h>
 313               	#elif defined (__AVR_ATtiny4__)
 314               	#  include <avr/iotn4.h>
 315               	#elif defined (__AVR_ATtiny5__)
 316               	#  include <avr/iotn5.h>
 317               	#elif defined (__AVR_ATtiny9__)
 318               	#  include <avr/iotn9.h>
 319               	#elif defined (__AVR_ATtiny10__)
 320               	#  include <avr/iotn10.h>
 321               	#elif defined (__AVR_ATtiny20__)
 322               	#  include <avr/iotn20.h>
 323               	#elif defined (__AVR_ATtiny40__)
 324               	#  include <avr/iotn40.h>
 325               	#elif defined (__AVR_ATtiny2313__)
 326               	#  include <avr/iotn2313.h>
 327               	#elif defined (__AVR_ATtiny2313A__)
 328               	#  include <avr/iotn2313a.h>
 329               	#elif defined (__AVR_ATtiny13__)
 330               	#  include <avr/iotn13.h>
 331               	#elif defined (__AVR_ATtiny13A__)
 332               	#  include <avr/iotn13a.h>
 333               	#elif defined (__AVR_ATtiny25__)
 334               	#  include <avr/iotn25.h>
 335               	#elif defined (__AVR_ATtiny4313__)
 336               	#  include <avr/iotn4313.h>
 337               	#elif defined (__AVR_ATtiny45__)
 338               	#  include <avr/iotn45.h>
 339               	#elif defined (__AVR_ATtiny85__)
GAS LISTING /tmp/ccWbVCMv.s 			page 24


 340               	#  include <avr/iotn85.h>
 341               	#elif defined (__AVR_ATtiny24__)
 342               	#  include <avr/iotn24.h>
 343               	#elif defined (__AVR_ATtiny24A__)
 344               	#  include <avr/iotn24a.h>
 345               	#elif defined (__AVR_ATtiny44__)
 346               	#  include <avr/iotn44.h>
 347               	#elif defined (__AVR_ATtiny44A__)
 348               	#  include <avr/iotn44a.h>
 349               	#elif defined (__AVR_ATtiny84__)
 350               	#  include <avr/iotn84.h>
 351               	#elif defined (__AVR_ATtiny84A__)
 352               	#  include <avr/iotn84a.h>  
 353               	#elif defined (__AVR_ATtiny261__)
 354               	#  include <avr/iotn261.h>
 355               	#elif defined (__AVR_ATtiny261A__)
 356               	#  include <avr/iotn261a.h>
 357               	#elif defined (__AVR_ATtiny461__)
 358               	#  include <avr/iotn461.h>
 359               	#elif defined (__AVR_ATtiny461A__)
 360               	#  include <avr/iotn461a.h>
 361               	#elif defined (__AVR_ATtiny861__)
 362               	#  include <avr/iotn861.h>
 363               	#elif defined (__AVR_ATtiny861A__)
 364               	#  include <avr/iotn861a.h>
 365               	#elif defined (__AVR_ATtiny43U__)
 366               	#  include <avr/iotn43u.h>
 367               	#elif defined (__AVR_ATtiny48__)
 368               	#  include <avr/iotn48.h>
 369               	#elif defined (__AVR_ATtiny88__)
 370               	#  include <avr/iotn88.h>
 371               	#elif defined (__AVR_ATtiny87__)
 372               	#  include <avr/iotn87.h>
 373               	#elif defined (__AVR_ATtiny167__)
 374               	#  include <avr/iotn167.h>
 375               	#elif defined (__AVR_AT90SCR100__)
 376               	#  include <avr/io90scr100.h>
 377               	#elif defined (__AVR_ATxmega16A4__)
 378               	#  include <avr/iox16a4.h>
 379               	#elif defined (__AVR_ATxmega16D4__)
 380               	#  include <avr/iox16d4.h>
 381               	#elif defined (__AVR_ATxmega32A4__)
 382               	#  include <avr/iox32a4.h>
 383               	#elif defined (__AVR_ATxmega32D4__)
 384               	#  include <avr/iox32d4.h>
 385               	#elif defined (__AVR_ATxmega64A1__)
 386               	#  include <avr/iox64a1.h>
 387               	#elif defined (__AVR_ATxmega64A1U__)
 388               	#  include <avr/iox64a1u.h>
 389               	#elif defined (__AVR_ATxmega64A3__)
 390               	#  include <avr/iox64a3.h>
 391               	#elif defined (__AVR_ATxmega64D3__)
 392               	#  include <avr/iox64d3.h>
 393               	#elif defined (__AVR_ATxmega128A1__)
 394               	#  include <avr/iox128a1.h>
 395               	#elif defined (__AVR_ATxmega128A1U__)
 396               	#  include <avr/iox128a1u.h>
GAS LISTING /tmp/ccWbVCMv.s 			page 25


 397               	#elif defined (__AVR_ATxmega128A3__)
 398               	#  include <avr/iox128a3.h>
 399               	#elif defined (__AVR_ATxmega128D3__)
 400               	#  include <avr/iox128d3.h>
 401               	#elif defined (__AVR_ATxmega192A3__)
 402               	#  include <avr/iox192a3.h>
 403               	#elif defined (__AVR_ATxmega192D3__)
 404               	#  include <avr/iox192d3.h>
 405               	#elif defined (__AVR_ATxmega256A3__)
 406               	#  include <avr/iox256a3.h>
 407               	#elif defined (__AVR_ATxmega256A3B__)
 408               	#  include <avr/iox256a3b.h>
 409               	#elif defined (__AVR_ATxmega256D3__)
 410               	#  include <avr/iox256d3.h>
 411               	#elif defined (__AVR_ATA6289__)
 412               	#  include <avr/ioa6289.h>
 413               	/* avr1: the following only supported for assembler programs */
 414               	#elif defined (__AVR_ATtiny28__)
 415               	#  include <avr/iotn28.h>
 416               	#elif defined (__AVR_AT90S1200__)
 417               	#  include <avr/io1200.h>
 418               	#elif defined (__AVR_ATtiny15__)
 419               	#  include <avr/iotn15.h>
 420               	#elif defined (__AVR_ATtiny12__)
 421               	#  include <avr/iotn12.h>
 422               	#elif defined (__AVR_ATtiny11__)
 423               	#  include <avr/iotn11.h>
 424               	#elif defined (__AVR_M3000__)
 425               	#  include <avr/iom3000.h>
 426               	#else
 427               	#  if !defined(__COMPILING_AVR_LIBC__)
 428               	#    warning "device type not defined"
 429               	#  endif
 430               	#endif
 431               	
 432               	#include <avr/portpins.h>
   1               	/* Copyright (c) 2003  Theodore A. Roth
 433               	
 434               	#include <avr/common.h>
   1               	/* Copyright (c) 2007 Eric B. Weddington
 435               	
 436               	#include <avr/version.h>
   1               	/* Copyright (c) 2005, Joerg Wunsch                               -*- c -*-
 437               	
 438               	/* Include fuse.h after individual IO header files. */
 439               	#include <avr/fuse.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 440               	
 441               	/* Include lock.h after individual IO header files. */
 442               	#include <avr/lock.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 443               	
 122               	#ifdef __ASSEMBLER__
  20               	#include "usbdrv.h"         /* for common defs */
   1               	/* Name: usbdrv.h
   2               	 * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   3               	 * Author: Christian Starkjohann
GAS LISTING /tmp/ccWbVCMv.s 			page 26


   4               	 * Creation Date: 2004-12-29
   5               	 * Tabsize: 4
   6               	 * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
   7               	 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
   8               	 * This Revision: $Id$
   9               	 */
  10               	
  11               	#ifndef __usbdrv_h_included__
  12               	#define __usbdrv_h_included__
  13               	#include "usbconfig.h"
   1               	/* Name: usbconfig.h
  14               	#include "usbportability.h"
  21               	
  22               	/* register names */
  23               	#define x1      r16
  24               	#define x2      r17
  25               	#define shift   r18
  26               	#define cnt     r19
  27               	#define x3      r20
  28               	#define x4      r21
  29               	#define x5		r22
  30               	#define bitcnt  x5
  31               	#define phase   x4
  32               	#define leap    x4
  33               	
  34               	/* Some assembler dependent definitions and declarations: */
  35               	
  36               	#ifdef __IAR_SYSTEMS_ASM__
  37               	    extern  usbRxBuf, usbDeviceAddr, usbNewDeviceAddr, usbInputBufOffset
  38               	    extern  usbCurrentTok, usbRxLen, usbRxToken, usbTxLen
  39               	    extern  usbTxBuf, usbTxStatus1, usbTxStatus3
  40               	#   if USB_COUNT_SOF
  41               	        extern usbSofCount
  42               	#   endif
  43               	    public  usbCrc16
  44               	    public  usbCrc16Append
  45               	
  46               	    COMMON  INTVEC
  47               	#   ifndef USB_INTR_VECTOR
  48               	        ORG     INT0_vect
  49               	#   else /* USB_INTR_VECTOR */
  50               	        ORG     USB_INTR_VECTOR
  51               	#       undef   USB_INTR_VECTOR
  52               	#   endif /* USB_INTR_VECTOR */
  53               	#   define  USB_INTR_VECTOR usbInterruptHandler
  54               	    rjmp    USB_INTR_VECTOR
  55               	    RSEG    CODE
  56               	
  57               	#else /* __IAR_SYSTEMS_ASM__ */
  58               	
  59               	#   ifndef USB_INTR_VECTOR /* default to hardware interrupt INT0 */
  60               	#       ifdef INT0_vect
  61               	#           define USB_INTR_VECTOR  INT0_vect       // this is the "new" define for the vector
  62               	#       else
  63               	#           define USB_INTR_VECTOR  SIG_INTERRUPT0  // this is the "old" vector
  64               	#       endif
  65               	#   endif
GAS LISTING /tmp/ccWbVCMv.s 			page 27


  66               	    .text
  67               	    .global USB_INTR_VECTOR
  68               	    .type   USB_INTR_VECTOR, @function
  69               	    .global usbCrc16
  70               	    .global usbCrc16Append
  71               	#endif /* __IAR_SYSTEMS_ASM__ */
  72               	
  73               	
  74               	#if USB_INTR_PENDING < 0x40 /* This is an I/O address, use in and out */
  75               	#   define  USB_LOAD_PENDING(reg)   in reg, USB_INTR_PENDING
  76               	#   define  USB_STORE_PENDING(reg)  out USB_INTR_PENDING, reg
  77               	#else   /* It's a memory address, use lds and sts */
  78               	#   define  USB_LOAD_PENDING(reg)   lds reg, USB_INTR_PENDING
  79               	#   define  USB_STORE_PENDING(reg)  sts USB_INTR_PENDING, reg
  80               	#endif
  81               	
  82               	#define usbTxLen1   usbTxStatus1
  83               	#define usbTxBuf1   (usbTxStatus1 + 1)
  84               	#define usbTxLen3   usbTxStatus3
  85               	#define usbTxBuf3   (usbTxStatus3 + 1)
  86               	
  87               	
  88               	;----------------------------------------------------------------------------
  89               	; Utility functions
  90               	;----------------------------------------------------------------------------
  91               	
  92               	#ifdef __IAR_SYSTEMS_ASM__
  93               	/* Register assignments for usbCrc16 on IAR cc */
  94               	/* Calling conventions on IAR:
  95               	 * First parameter passed in r16/r17, second in r18/r19 and so on.
  96               	 * Callee must preserve r4-r15, r24-r29 (r28/r29 is frame pointer)
  97               	 * Result is passed in r16/r17
  98               	 * In case of the "tiny" memory model, pointers are only 8 bit with no
  99               	 * padding. We therefore pass argument 1 as "16 bit unsigned".
 100               	 */
 101               	RTMODEL "__rt_version", "3"
 102               	/* The line above will generate an error if cc calling conventions change.
 103               	 * The value "3" above is valid for IAR 4.10B/W32
 104               	 */
 105               	#   define argLen   r18 /* argument 2 */
 106               	#   define argPtrL  r16 /* argument 1 */
 107               	#   define argPtrH  r17 /* argument 1 */
 108               	
 109               	#   define resCrcL  r16 /* result */
 110               	#   define resCrcH  r17 /* result */
 111               	
 112               	#   define ptrL     ZL
 113               	#   define ptrH     ZH
 114               	#   define ptr      Z
 115               	#   define byte     r22
 116               	#   define bitCnt   r19
 117               	#   define polyL    r20
 118               	#   define polyH    r21
 119               	#   define scratch  r23
 120               	
 121               	#else  /* __IAR_SYSTEMS_ASM__ */ 
 122               	/* Register assignments for usbCrc16 on gcc */
GAS LISTING /tmp/ccWbVCMv.s 			page 28


 123               	/* Calling conventions on gcc:
 124               	 * First parameter passed in r24/r25, second in r22/23 and so on.
 125               	 * Callee must preserve r1-r17, r28/r29
 126               	 * Result is passed in r24/r25
 127               	 */
 128               	#   define argLen   r22 /* argument 2 */
 129               	#   define argPtrL  r24 /* argument 1 */
 130               	#   define argPtrH  r25 /* argument 1 */
 131               	
 132               	#   define resCrcL  r24 /* result */
 133               	#   define resCrcH  r25 /* result */
 134               	
 135               	#   define ptrL     XL
 136               	#   define ptrH     XH
 137               	#   define ptr      x
 138               	#   define byte     r18
 139               	#   define bitCnt   r19
 140               	#   define polyL    r20
 141               	#   define polyH    r21
 142               	#   define scratch  r23
 143               	
 144               	#endif
 145               	
 146               	#if USB_USE_FAST_CRC
 147               	
 148               	; This implementation is faster, but has bigger code size
 149               	; Thanks to Slawomir Fras (BoskiDialer) for this code!
 150               	; It implements the following C pseudo-code:
 151               	; unsigned table(unsigned char x)
 152               	; {
 153               	; unsigned    value;
 154               	; 
 155               	;     value = (unsigned)x << 6;
 156               	;     value ^= (unsigned)x << 7;
 157               	;     if(parity(x))
 158               	;         value ^= 0xc001;
 159               	;     return value;
 160               	; }
 161               	; unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen)
 162               	; {
 163               	; unsigned crc = 0xffff;
 164               	; 
 165               	;     while(argLen--)
 166               	;         crc = table(lo8(crc) ^ *argPtr++) ^ hi8(crc);
 167               	;     return ~crc;
 168               	; }
 169               	
 170               	; extern unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen);
 171               	;   argPtr  r24+25 / r16+r17
 172               	;   argLen  r22 / r18
 173               	; temp variables:
 174               	;   byte    r18 / r22
 175               	;   scratch r23
 176               	;   resCrc  r24+r25 / r16+r17
 177               	;   ptr     X / Z
 178               	usbCrc16:
 179               	    mov     ptrL, argPtrL
GAS LISTING /tmp/ccWbVCMv.s 			page 29


 180               	    mov     ptrH, argPtrH
 181               	    ldi     resCrcL, 0xFF
 182               	    ldi     resCrcH, 0xFF
 183               	    rjmp    usbCrc16LoopTest
 184               	usbCrc16ByteLoop:
 185               	    ld      byte, ptr+
 186               	    eor     resCrcL, byte   ; resCrcL is now 'x' in table()
 187               	    mov     byte, resCrcL   ; compute parity of 'x'
 188               	    swap    byte
 189               	    eor     byte, resCrcL
 190               	    mov     scratch, byte
 191               	    lsr     byte
 192               	    lsr     byte
 193               	    eor     byte, scratch
 194               	    inc     byte
 195               	    lsr     byte
 196               	    andi    byte, 1         ; byte is now parity(x)
 197               	    mov     scratch, resCrcL
 198               	    mov     resCrcL, resCrcH
 199               	    eor     resCrcL, byte   ; low byte of if(parity(x)) value ^= 0xc001;
 200               	    neg     byte
 201               	    andi    byte, 0xc0
 202               	    mov     resCrcH, byte   ; high byte of if(parity(x)) value ^= 0xc001;
 203               	    clr     byte
 204               	    lsr     scratch
 205               	    ror     byte
 206               	    eor     resCrcH, scratch
 207               	    eor     resCrcL, byte
 208               	    lsr     scratch
 209               	    ror     byte
 210               	    eor     resCrcH, scratch
 211               	    eor     resCrcL, byte
 212               	usbCrc16LoopTest:
 213               	    subi    argLen, 1
 214               	    brsh    usbCrc16ByteLoop
 215               	    com     resCrcL
 216               	    com     resCrcH
 217               	    ret
 218               	
 219               	#else   /* USB_USE_FAST_CRC */
 220               	
 221               	; This implementation is slower, but has less code size
 222               	;
 223               	; extern unsigned usbCrc16(unsigned char *argPtr, unsigned char argLen);
 224               	;   argPtr  r24+25 / r16+r17
 225               	;   argLen  r22 / r18
 226               	; temp variables:
 227               	;   byte    r18 / r22
 228               	;   bitCnt  r19
 229               	;   poly    r20+r21
 230               	;   scratch r23
 231               	;   resCrc  r24+r25 / r16+r17
 232               	;   ptr     X / Z
 233               	usbCrc16:
 234:../lib/usbdrv/usbdrvasm.S ****     mov     ptrL, argPtrL
 235:../lib/usbdrv/usbdrvasm.S ****     mov     ptrH, argPtrH
 236:../lib/usbdrv/usbdrvasm.S ****     ldi     resCrcL, 0
GAS LISTING /tmp/ccWbVCMv.s 			page 30


 237:../lib/usbdrv/usbdrvasm.S ****     ldi     resCrcH, 0
 238:../lib/usbdrv/usbdrvasm.S ****     ldi     polyL, lo8(0xa001)
 239:../lib/usbdrv/usbdrvasm.S ****     ldi     polyH, hi8(0xa001)
 240:../lib/usbdrv/usbdrvasm.S ****     com     argLen      ; argLen = -argLen - 1: modified loop to ensure that carry is set
 241:../lib/usbdrv/usbdrvasm.S ****     ldi     bitCnt, 0   ; loop counter with starnd condition = end condition
 242:../lib/usbdrv/usbdrvasm.S ****     rjmp    usbCrcLoopEntry
 243               	usbCrcByteLoop:
 244:../lib/usbdrv/usbdrvasm.S ****     ld      byte, ptr+
 245:../lib/usbdrv/usbdrvasm.S ****     eor     resCrcL, byte
 246               	usbCrcBitLoop:
 247:../lib/usbdrv/usbdrvasm.S ****     ror     resCrcH     ; carry is always set here (see brcs jumps to here)
 248:../lib/usbdrv/usbdrvasm.S ****     ror     resCrcL
 249:../lib/usbdrv/usbdrvasm.S ****     brcs    usbCrcNoXor
 250:../lib/usbdrv/usbdrvasm.S ****     eor     resCrcL, polyL
 251:../lib/usbdrv/usbdrvasm.S ****     eor     resCrcH, polyH
 252               	usbCrcNoXor:
 253:../lib/usbdrv/usbdrvasm.S ****     subi    bitCnt, 224 ; (8 * 224) % 256 = 0; this loop iterates 8 times
 254:../lib/usbdrv/usbdrvasm.S ****     brcs    usbCrcBitLoop
 255               	usbCrcLoopEntry:
 256:../lib/usbdrv/usbdrvasm.S ****     subi    argLen, -1
 257:../lib/usbdrv/usbdrvasm.S ****     brcs    usbCrcByteLoop
 258               	usbCrcReady:
 259:../lib/usbdrv/usbdrvasm.S ****     ret
 260               	; Thanks to Reimar Doeffinger for optimizing this CRC routine!
 261               	
 262               	#endif /* USB_USE_FAST_CRC */
 263               	
 264               	; extern unsigned usbCrc16Append(unsigned char *data, unsigned char len);
 265               	usbCrc16Append:
 266:../lib/usbdrv/usbdrvasm.S ****     rcall   usbCrc16
 267:../lib/usbdrv/usbdrvasm.S ****     st      ptr+, resCrcL
 268:../lib/usbdrv/usbdrvasm.S ****     st      ptr+, resCrcH
 269:../lib/usbdrv/usbdrvasm.S ****     ret
 270               	
 271               	#undef argLen
 272               	#undef argPtrL
 273               	#undef argPtrH
 274               	#undef resCrcL
 275               	#undef resCrcH
 276               	#undef ptrL
 277               	#undef ptrH
 278               	#undef ptr
 279               	#undef byte
 280               	#undef bitCnt
 281               	#undef polyL
 282               	#undef polyH
 283               	#undef scratch
 284               	
 285               	
 286               	#if USB_CFG_HAVE_MEASURE_FRAME_LENGTH
 287               	#ifdef __IAR_SYSTEMS_ASM__
 288               	/* Register assignments for usbMeasureFrameLength on IAR cc */
 289               	/* Calling conventions on IAR:
 290               	 * First parameter passed in r16/r17, second in r18/r19 and so on.
 291               	 * Callee must preserve r4-r15, r24-r29 (r28/r29 is frame pointer)
 292               	 * Result is passed in r16/r17
 293               	 * In case of the "tiny" memory model, pointers are only 8 bit with no
GAS LISTING /tmp/ccWbVCMv.s 			page 31


 294               	 * padding. We therefore pass argument 1 as "16 bit unsigned".
 295               	 */
 296               	#   define resL     r16
 297               	#   define resH     r17
 298               	#   define cnt16L   r30
 299               	#   define cnt16H   r31
 300               	#   define cntH     r18
 301               	
 302               	#else  /* __IAR_SYSTEMS_ASM__ */ 
 303               	/* Register assignments for usbMeasureFrameLength on gcc */
 304               	/* Calling conventions on gcc:
 305               	 * First parameter passed in r24/r25, second in r22/23 and so on.
 306               	 * Callee must preserve r1-r17, r28/r29
 307               	 * Result is passed in r24/r25
 308               	 */
 309               	#   define resL     r24
 310               	#   define resH     r25
 311               	#   define cnt16L   r24
 312               	#   define cnt16H   r25
 313               	#   define cntH     r26
 314               	#endif
 315               	#   define cnt16    cnt16L
 316               	
 317               	; extern unsigned usbMeasurePacketLength(void);
 318               	; returns time between two idle strobes in multiples of 7 CPU clocks
 319               	.global usbMeasureFrameLength
 320               	usbMeasureFrameLength:
 321               	    ldi     cntH, 6         ; wait ~ 10 ms for D- == 0
 322               	    clr     cnt16L
 323               	    clr     cnt16H
 324               	usbMFTime16:
 325               	    dec     cntH
 326               	    breq    usbMFTimeout
 327               	usbMFWaitStrobe:            ; first wait for D- == 0 (idle strobe)
 328               	    sbiw    cnt16, 1        ;[0] [6]
 329               	    breq    usbMFTime16     ;[2]
 330               	    sbic    USBIN, USBMINUS ;[3]
 331               	    rjmp    usbMFWaitStrobe ;[4]
 332               	usbMFWaitIdle:              ; then wait until idle again
 333               	    sbis    USBIN, USBMINUS ;1 wait for D- == 1
 334               	    rjmp    usbMFWaitIdle   ;2
 335               	    ldi     cnt16L, 1       ;1 represents cycles so far
 336               	    clr     cnt16H          ;1
 337               	usbMFWaitLoop:
 338               	    in      cntH, USBIN     ;[0] [7]
 339               	    adiw    cnt16, 1        ;[1]
 340               	    breq    usbMFTimeout    ;[3]
 341               	    andi    cntH, USBMASK   ;[4]
 342               	    brne    usbMFWaitLoop   ;[5]
 343               	usbMFTimeout:
 344               	#if resL != cnt16L
 345               	    mov     resL, cnt16L
 346               	    mov     resH, cnt16H
 347               	#endif
 348               	    ret
 349               	
 350               	#undef resL
GAS LISTING /tmp/ccWbVCMv.s 			page 32


 351               	#undef resH
 352               	#undef cnt16
 353               	#undef cnt16L
 354               	#undef cnt16H
 355               	#undef cntH
 356               	
 357               	#endif  /* USB_CFG_HAVE_MEASURE_FRAME_LENGTH */
 358               	
 359               	;----------------------------------------------------------------------------
 360               	; Now include the clock rate specific code
 361               	;----------------------------------------------------------------------------
 362               	
 363               	#ifndef USB_CFG_CLOCK_KHZ
 364               	#   ifdef F_CPU
 365               	#       define USB_CFG_CLOCK_KHZ (F_CPU/1000)
 366               	#   else
 367               	#       error "USB_CFG_CLOCK_KHZ not defined in usbconfig.h and no F_CPU set!"
 368               	#   endif
 369               	#endif
 370               	
 371               	#if USB_CFG_CHECK_CRC   /* separate dispatcher for CRC type modules */
 372               	#   if USB_CFG_CLOCK_KHZ == 18000
 373               	#       include "usbdrvasm18-crc.inc"
 374               	#   else
 375               	#       error "USB_CFG_CLOCK_KHZ is not one of the supported crc-rates!"
 376               	#   endif
 377               	#else   /* USB_CFG_CHECK_CRC */
 378               	#   if USB_CFG_CLOCK_KHZ == 12000
 379               	#       include "usbdrvasm12.inc"
 380               	#   elif USB_CFG_CLOCK_KHZ == 12800
 381               	#       include "usbdrvasm128.inc"
 382               	#   elif USB_CFG_CLOCK_KHZ == 15000
 383               	#       include "usbdrvasm15.inc"
 384               	#   elif USB_CFG_CLOCK_KHZ == 16000
 385               	#       include "usbdrvasm16.inc"
 386               	#   elif USB_CFG_CLOCK_KHZ == 16500
 387               	#       include "usbdrvasm165.inc"
 388               	#   elif USB_CFG_CLOCK_KHZ == 20000
 389               	#       include "usbdrvasm20.inc"
   1               	/* Name: usbdrvasm20.inc
   2               	 * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   3               	 * Author: Jeroen Benschop
   4               	 * Based on usbdrvasm16.inc from Christian Starkjohann
   5               	 * Creation Date: 2008-03-05
   6               	 * Tabsize: 4
   7               	 * Copyright: (c) 2008 by Jeroen Benschop and OBJECTIVE DEVELOPMENT Software GmbH
   8               	 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
   9               	 * Revision: $Id$
  10               	 */
  11               	
  12               	/* Do not link this file! Link usbdrvasm.S instead, which includes the
  13               	 * appropriate implementation!
  14               	 */
  15               	
  16               	/*
  17               	General Description:
  18               	This file is the 20 MHz version of the asssembler part of the USB driver. It
GAS LISTING /tmp/ccWbVCMv.s 			page 33


  19               	requires a 20 MHz crystal (not a ceramic resonator and not a calibrated RC
  20               	oscillator).
  21               	
  22               	See usbdrv.h for a description of the entire driver.
  23               	
  24               	Since almost all of this code is timing critical, don't change unless you
  25               	really know what you are doing! Many parts require not only a maximum number
  26               	of CPU cycles, but even an exact number of cycles!
  27               	*/
  28               	
  29               	#define leap2   x3
  30               	#ifdef __IAR_SYSTEMS_ASM__
  31               	#define nextInst    $+2
  32               	#else
  33               	#define nextInst    .+0
  34               	#endif
  35               	
  36               	;max stack usage: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 bytes
  37               	;nominal frequency: 20 MHz -> 13.333333 cycles per bit, 106.666667 cycles per byte
  38               	; Numbers in brackets are clocks counted from center of last sync bit
  39               	; when instruction starts
  40               	;register use in receive loop:
  41               	; shift assembles the byte currently being received
  42               	; x1 holds the D+ and D- line state
  43               	; x2 holds the previous line state
  44               	; x4 (leap)  is used to add a leap cycle once every three bytes received
  45               	; X3 (leap2) is used to add a leap cycle once every three stuff bits received
  46               	; bitcnt is used to determine when a stuff bit is due
  47               	; cnt holds the number of bytes left in the receive buffer
  48               	
  49               	USB_INTR_VECTOR:
  50               	;order of registers pushed: YL, SREG YH, [sofError], bitcnt, shift, x1, x2, x3, x4, cnt
  51:../lib/usbdrv/usbdrvasm20.inc ****     push    YL                  ;[-28] push only what is necessary to sync with edge ASAP
  52:../lib/usbdrv/usbdrvasm20.inc ****     in      YL, SREG            ;[-26]
  53:../lib/usbdrv/usbdrvasm20.inc ****     push    YL                  ;[-25]
  54:../lib/usbdrv/usbdrvasm20.inc ****     push    YH                  ;[-23]
  55               	;----------------------------------------------------------------------------
  56               	; Synchronize with sync pattern:
  57               	;----------------------------------------------------------------------------
  58               	;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
  59               	;sync up with J to K edge during sync pattern -- use fastest possible loops
  60               	;The first part waits at most 1 bit long since we must be in sync pattern.
  61               	;YL is guarenteed to be < 0x80 because I flag is clear. When we jump to
  62               	;waitForJ, ensure that this prerequisite is met.
  63               	waitForJ:
  64:../lib/usbdrv/usbdrvasm20.inc ****     inc     YL
  65:../lib/usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
  66:../lib/usbdrv/usbdrvasm20.inc ****     brne    waitForJ        ; just make sure we have ANY timeout
  67               	waitForK:
  68               	;The following code results in a sampling window of < 1/4 bit which meets the spec.
  69:../lib/usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS     ;[-19]
  70:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    foundK              ;[-18]
  71:../lib/usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
  72:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    foundK
  73:../lib/usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
  74:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    foundK
  75:../lib/usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
GAS LISTING /tmp/ccWbVCMv.s 			page 34


  76:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    foundK
  77:../lib/usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
  78:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    foundK
  79:../lib/usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
  80:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    foundK
  81:../lib/usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
  82:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    foundK
  83:../lib/usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
  84:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    foundK
  85:../lib/usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS
  86:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    foundK
  87               	#if USB_COUNT_SOF
  88:../lib/usbdrv/usbdrvasm20.inc ****     lds     YL, usbSofCount
  89:../lib/usbdrv/usbdrvasm20.inc ****     inc     YL
  90:../lib/usbdrv/usbdrvasm20.inc ****     sts     usbSofCount, YL
  91:../lib/usbdrv/usbdrvasm20.inc **** #endif  /* USB_COUNT_SOF */
  92:../lib/usbdrv/usbdrvasm20.inc **** #ifdef USB_SOF_HOOK
  93:../lib/usbdrv/usbdrvasm20.inc ****     USB_SOF_HOOK
  94:../lib/usbdrv/usbdrvasm20.inc **** #endif
  95:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    sofError
  96               	foundK:                         ;[-16]
  97               	;{3, 5} after falling D- edge, average delay: 4 cycles
  98               	;bit0 should be at 34 for center sampling. Currently at 4 so 30 cylces till bit 0 sample
  99               	;use 1 bit time for setup purposes, then sample again. Numbers in brackets
 100               	;are cycles from center of first sync (double K) bit after the instruction
 101:../lib/usbdrv/usbdrvasm20.inc ****     push    bitcnt              ;[-16]
 102               	;   [---]                       ;[-15]
 103:../lib/usbdrv/usbdrvasm20.inc ****     lds     YL, usbInputBufOffset;[-14]
 104               	;   [---]                       ;[-13]
 105:../lib/usbdrv/usbdrvasm20.inc ****     clr     YH                  ;[-12]
 106:../lib/usbdrv/usbdrvasm20.inc ****     subi    YL, lo8(-(usbRxBuf));[-11] [rx loop init]
 107:../lib/usbdrv/usbdrvasm20.inc ****     sbci    YH, hi8(-(usbRxBuf));[-10] [rx loop init]
 108:../lib/usbdrv/usbdrvasm20.inc ****     push    shift               ;[-9]
 109               	;   [---]                       ;[-8]
 110:../lib/usbdrv/usbdrvasm20.inc ****     ldi     shift,0x40          ;[-7] set msb to "1" so processing bit7 can be detected
 111:../lib/usbdrv/usbdrvasm20.inc ****     nop2                        ;[-6]
 112               	;   [---]                       ;[-5]
 113:../lib/usbdrv/usbdrvasm20.inc ****     ldi     bitcnt, 5           ;[-4] [rx loop init]
 114:../lib/usbdrv/usbdrvasm20.inc ****     sbis    USBIN, USBMINUS     ;[-3] we want two bits K (sample 3 cycles too early)
 115:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    haveTwoBitsK        ;[-2]
 116:../lib/usbdrv/usbdrvasm20.inc ****     pop     shift               ;[-1] undo the push from before
 117:../lib/usbdrv/usbdrvasm20.inc ****     pop     bitcnt              ;[1] 
 118:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    waitForK            ;[3] this was not the end of sync, retry
 119               	; The entire loop from waitForK until rjmp waitForK above must not exceed two
 120               	; bit times (= 27 cycles).
 121               	
 122               	;----------------------------------------------------------------------------
 123               	; push more registers and initialize values while we sample the first bits:
 124               	;----------------------------------------------------------------------------
 125               	haveTwoBitsK:
 126:../lib/usbdrv/usbdrvasm20.inc ****     push    x1                  ;[0]
 127:../lib/usbdrv/usbdrvasm20.inc ****     push    x2                  ;[2]
 128:../lib/usbdrv/usbdrvasm20.inc ****     push    x3                  ;[4] (leap2)
 129:../lib/usbdrv/usbdrvasm20.inc ****     ldi     leap2, 0x55         ;[6] add leap cycle on 2nd,5th,8th,... stuff bit
 130:../lib/usbdrv/usbdrvasm20.inc ****     push    x4                  ;[7] == leap
 131:../lib/usbdrv/usbdrvasm20.inc ****     ldi     leap, 0x55          ;[9] skip leap cycle on 2nd,5th,8th,... byte received
 132:../lib/usbdrv/usbdrvasm20.inc ****     push    cnt                 ;[10]
GAS LISTING /tmp/ccWbVCMv.s 			page 35


 133:../lib/usbdrv/usbdrvasm20.inc ****     ldi     cnt, USB_BUFSIZE    ;[12] [rx loop init]
 134:../lib/usbdrv/usbdrvasm20.inc ****     ldi     x2, 1<<USBPLUS      ;[13] current line state is K state. D+=="1", D-=="0"
 135               	bit0:       
 136:../lib/usbdrv/usbdrvasm20.inc ****     in      x1, USBIN           ;[0] sample line state
 137:../lib/usbdrv/usbdrvasm20.inc ****     andi    x1, USBMASK         ;[1] filter only D+ and D- bits
 138:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    handleBit           ;[2] make bit0 14 cycles long
 139               	
 140               	;----------------------------------------------------------------------------
 141               	; Process bit7. However, bit 6 still may need unstuffing.
 142               	;----------------------------------------------------------------------------
 143               	
 144               	b6checkUnstuff:
 145:../lib/usbdrv/usbdrvasm20.inc ****     dec     bitcnt              ;[9]
 146:../lib/usbdrv/usbdrvasm20.inc ****     breq    unstuff6            ;[10]
 147               	bit7:
 148:../lib/usbdrv/usbdrvasm20.inc ****     subi    cnt, 1              ;[11] cannot use dec becaus it does not affect the carry flag
 149:../lib/usbdrv/usbdrvasm20.inc ****     brcs    overflow            ;[12] Too many bytes received. Ignore packet
 150:../lib/usbdrv/usbdrvasm20.inc ****     in      x1, USBIN           ;[0] sample line state
 151:../lib/usbdrv/usbdrvasm20.inc ****     andi    x1, USBMASK         ;[1] filter only D+ and D- bits
 152:../lib/usbdrv/usbdrvasm20.inc ****     cpse    x1, x2              ;[2] when previous line state equals current line state, handle "1"
 153:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    b7handle0           ;[3] when line state differs, handle "0"
 154:../lib/usbdrv/usbdrvasm20.inc ****     sec                         ;[4]
 155:../lib/usbdrv/usbdrvasm20.inc ****     ror     shift               ;[5] shift "1" into the data
 156:../lib/usbdrv/usbdrvasm20.inc ****     st      y+, shift           ;[6] store the data into the buffer
 157:../lib/usbdrv/usbdrvasm20.inc ****     ldi     shift, 0x40         ;[7] reset data for receiving the next byte
 158:../lib/usbdrv/usbdrvasm20.inc ****     subi    leap, 0x55          ;[9] trick to introduce a leap cycle every 3 bytes
 159:../lib/usbdrv/usbdrvasm20.inc ****     brcc    nextInst            ;[10 or 11] it will fail after 85 bytes. However low speed can only
 160:../lib/usbdrv/usbdrvasm20.inc ****     dec     bitcnt              ;[11 or 12]
 161:../lib/usbdrv/usbdrvasm20.inc ****     brne    bit0                ;[12 or 13]
 162:../lib/usbdrv/usbdrvasm20.inc ****     ldi     x1, 1               ;[13 or 14] unstuffing bit 7
 163:../lib/usbdrv/usbdrvasm20.inc ****     in      bitcnt, USBIN       ;[0] sample stuff bit
 164:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    unstuff             ;[1]
 165               	
 166               	b7handle0:
 167:../lib/usbdrv/usbdrvasm20.inc ****     mov     x2,x1               ;[5] Set x2 to current line state
 168:../lib/usbdrv/usbdrvasm20.inc ****     ldi     bitcnt, 6           ;[6]
 169:../lib/usbdrv/usbdrvasm20.inc ****     lsr     shift               ;[7] shift "0" into the data
 170:../lib/usbdrv/usbdrvasm20.inc ****     st      y+, shift           ;[8] store data into the buffer
 171:../lib/usbdrv/usbdrvasm20.inc ****     ldi     shift, 0x40         ;[10] reset data for receiving the next byte
 172:../lib/usbdrv/usbdrvasm20.inc ****     subi    leap, 0x55          ;[11] trick to introduce a leap cycle every 3 bytes
 173:../lib/usbdrv/usbdrvasm20.inc ****     brcs    bit0                ;[12] it will fail after 85 bytes. However low speed can only recei
 174:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    bit0                ;[13]
 175               	
 176               	
 177               	;----------------------------------------------------------------------------
 178               	; Handle unstuff
 179               	; x1==0xFF indicate unstuffing bit6
 180               	;----------------------------------------------------------------------------
 181               	
 182               	unstuff6:
 183:../lib/usbdrv/usbdrvasm20.inc ****     ldi     x1,0xFF             ;[12] indicate unstuffing bit 6
 184:../lib/usbdrv/usbdrvasm20.inc ****     in      bitcnt, USBIN       ;[0]  sample stuff bit
 185:../lib/usbdrv/usbdrvasm20.inc ****     nop                         ;[1]  fix timing
 186               	unstuff:                        ;b0-5  b6   b7
 187:../lib/usbdrv/usbdrvasm20.inc ****     mov     x2,bitcnt           ;[3]  [2]  [3]  Set x2 to match line state
 188:../lib/usbdrv/usbdrvasm20.inc ****     subi    leap2, 0x55         ;[4]  [3]  [4]  delay loop
 189:../lib/usbdrv/usbdrvasm20.inc ****     brcs    nextInst            ;[5]  [4]  [5]  add one cycle every three stuff bits
GAS LISTING /tmp/ccWbVCMv.s 			page 36


 190:../lib/usbdrv/usbdrvasm20.inc ****     sbci    leap2,0             ;[6]  [5]  [6]
 191:../lib/usbdrv/usbdrvasm20.inc ****     ldi     bitcnt,6            ;[7]  [6]  [7]  reset bit stuff counter
 192:../lib/usbdrv/usbdrvasm20.inc ****     andi    x2, USBMASK         ;[8]  [7]  [8] only keep D+ and D-
 193:../lib/usbdrv/usbdrvasm20.inc ****     cpi     x1,0                ;[9]  [8]  [9]
 194:../lib/usbdrv/usbdrvasm20.inc ****     brmi    bit7                ;[10] [9]  [10] finished unstuffing bit6 When x1<0
 195:../lib/usbdrv/usbdrvasm20.inc ****     breq    bitloop             ;[11] ---  [11] finished unstuffing bit0-5 when x1=0
 196:../lib/usbdrv/usbdrvasm20.inc ****     nop                         ;---  ---  [12]
 197:../lib/usbdrv/usbdrvasm20.inc ****     in      x1, USBIN           ;---  ---  [0] sample line state for bit0
 198:../lib/usbdrv/usbdrvasm20.inc ****     andi    x1, USBMASK         ;---  ---  [1] filter only D+ and D- bits
 199:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    handleBit           ;---  ---  [2] make bit0 14 cycles long
 200               	
 201               	;----------------------------------------------------------------------------
 202               	; Receiver loop (numbers in brackets are cycles within byte after instr)
 203               	;----------------------------------------------------------------------------
 204               	bitloop:
 205:../lib/usbdrv/usbdrvasm20.inc ****     in      x1, USBIN           ;[0] sample line state
 206:../lib/usbdrv/usbdrvasm20.inc ****     andi    x1, USBMASK         ;[1] filter only D+ and D- bits
 207:../lib/usbdrv/usbdrvasm20.inc ****     breq    se0                 ;[2] both lines are low so handle se0
 208               	handleBit:
 209:../lib/usbdrv/usbdrvasm20.inc ****     cpse    x1, x2              ;[3] when previous line state equals current line state, handle "1"
 210:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    handle0             ;[4] when line state differs, handle "0"
 211:../lib/usbdrv/usbdrvasm20.inc ****     sec                         ;[5]
 212:../lib/usbdrv/usbdrvasm20.inc ****     ror     shift               ;[6] shift "1" into the data
 213:../lib/usbdrv/usbdrvasm20.inc ****     brcs    b6checkUnstuff      ;[7] When after shift C is set, next bit is bit7
 214:../lib/usbdrv/usbdrvasm20.inc ****     nop2                        ;[8]
 215:../lib/usbdrv/usbdrvasm20.inc ****     dec     bitcnt              ;[10]
 216:../lib/usbdrv/usbdrvasm20.inc ****     brne    bitloop             ;[11]
 217:../lib/usbdrv/usbdrvasm20.inc ****     ldi     x1,0                ;[12] indicate unstuff for bit other than bit6 or bit7
 218:../lib/usbdrv/usbdrvasm20.inc ****     in      bitcnt, USBIN       ;[0] sample stuff bit
 219:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    unstuff             ;[1]
 220               	
 221               	handle0:
 222:../lib/usbdrv/usbdrvasm20.inc ****     mov     x2, x1              ;[6] Set x2 to current line state
 223:../lib/usbdrv/usbdrvasm20.inc ****     ldi     bitcnt, 6           ;[7] reset unstuff counter. 
 224:../lib/usbdrv/usbdrvasm20.inc ****     lsr     shift               ;[8] shift "0" into the data
 225:../lib/usbdrv/usbdrvasm20.inc ****     brcs    bit7                ;[9] When after shift C is set, next bit is bit7
 226:../lib/usbdrv/usbdrvasm20.inc ****     nop                         ;[10]
 227:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    bitloop             ;[11] 
 228               	    
 229               	;----------------------------------------------------------------------------
 230               	; End of receive loop. Now start handling EOP
 231               	;----------------------------------------------------------------------------
 232               	
 233               	macro POP_STANDARD ; 14 cycles
 234               	    pop     cnt
 235               	    pop     x4
 236               	    pop     x3
 237               	    pop     x2
 238               	    pop     x1
 239               	    pop     shift
 240               	    pop     bitcnt
 241               	    endm
 242               	macro POP_RETI     ; 7 cycles
 243               	    pop     YH
 244               	    pop     YL
 245               	    out     SREG, YL
 246               	    pop     YL
GAS LISTING /tmp/ccWbVCMv.s 			page 37


 247               	    endm
 248               	
 249               	
 250               	
 251               	#include "asmcommon.inc"
   1               	/* Name: asmcommon.inc
   2               	 * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   3               	 * Author: Christian Starkjohann
   4               	 * Creation Date: 2007-11-05
   5               	 * Tabsize: 4
   6               	 * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
   7               	 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
   8               	 * Revision: $Id$
   9               	 */
  10               	
  11               	/* Do not link this file! Link usbdrvasm.S instead, which includes the
  12               	 * appropriate implementation!
  13               	 */
  14               	
  15               	/*
  16               	General Description:
  17               	This file contains assembler code which is shared among the USB driver
  18               	implementations for different CPU cocks. Since the code must be inserted
  19               	in the middle of the module, it's split out into this file and #included.
  20               	
  21               	Jump destinations called from outside:
  22               	    sofError: Called when no start sequence was found.
  23               	    se0: Called when a package has been successfully received.
  24               	    overflow: Called when receive buffer overflows.
  25               	    doReturn: Called after sending data.
  26               	
  27               	Outside jump destinations used by this module:
  28               	    waitForJ: Called to receive an already arriving packet.
  29               	    sendAckAndReti:
  30               	    sendNakAndReti:
  31               	    sendCntAndReti:
  32               	    usbSendAndReti:
  33               	
  34               	The following macros must be defined before this file is included:
  35               	    .macro POP_STANDARD
  36               	    .endm
  37               	    .macro POP_RETI
  38               	    .endm
  39               	*/
  40               	
  41               	#define token   x1
  42               	
  43               	overflow:
  44:../lib/usbdrv/asmcommon.inc ****     ldi     x2, 1<<USB_INTR_PENDING_BIT
  45:../lib/usbdrv/asmcommon.inc ****     USB_STORE_PENDING(x2)       ; clear any pending interrupts
  46               	ignorePacket:
  47:../lib/usbdrv/asmcommon.inc ****     clr     token
  48:../lib/usbdrv/asmcommon.inc ****     rjmp    storeTokenAndReturn
  49               	
  50               	;----------------------------------------------------------------------------
  51               	; Processing of received packet (numbers in brackets are cycles after center of SE0)
  52               	;----------------------------------------------------------------------------
GAS LISTING /tmp/ccWbVCMv.s 			page 38


  53               	;This is the only non-error exit point for the software receiver loop
  54               	;we don't check any CRCs here because there is no time left.
  55               	se0:
  56:../lib/usbdrv/asmcommon.inc ****     subi    cnt, USB_BUFSIZE    ;[5]
  57:../lib/usbdrv/asmcommon.inc ****     neg     cnt                 ;[6]
  58:../lib/usbdrv/asmcommon.inc ****     sub     YL, cnt             ;[7]
  59:../lib/usbdrv/asmcommon.inc ****     sbci    YH, 0               ;[8]
  60:../lib/usbdrv/asmcommon.inc ****     ldi     x2, 1<<USB_INTR_PENDING_BIT ;[9]
  61:../lib/usbdrv/asmcommon.inc ****     USB_STORE_PENDING(x2)       ;[10] clear pending intr and check flag later. SE0 should be over.
  62:../lib/usbdrv/asmcommon.inc ****     ld      token, y            ;[11]
  63:../lib/usbdrv/asmcommon.inc ****     cpi     token, USBPID_DATA0 ;[13]
  64:../lib/usbdrv/asmcommon.inc ****     breq    handleData          ;[14]
  65:../lib/usbdrv/asmcommon.inc ****     cpi     token, USBPID_DATA1 ;[15]
  66:../lib/usbdrv/asmcommon.inc ****     breq    handleData          ;[16]
  67:../lib/usbdrv/asmcommon.inc ****     lds     shift, usbDeviceAddr;[17]
  68:../lib/usbdrv/asmcommon.inc ****     ldd     x2, y+1             ;[19] ADDR and 1 bit endpoint number
  69:../lib/usbdrv/asmcommon.inc ****     lsl     x2                  ;[21] shift out 1 bit endpoint number
  70:../lib/usbdrv/asmcommon.inc ****     cpse    x2, shift           ;[22]
  71:../lib/usbdrv/asmcommon.inc ****     rjmp    ignorePacket        ;[23]
  72               	/* only compute endpoint number in x3 if required later */
  73               	#if USB_CFG_HAVE_INTRIN_ENDPOINT || USB_CFG_IMPLEMENT_FN_WRITEOUT
  74:../lib/usbdrv/asmcommon.inc ****     ldd     x3, y+2             ;[24] endpoint number + crc
  75:../lib/usbdrv/asmcommon.inc ****     rol     x3                  ;[26] shift in LSB of endpoint
  76               	#endif
  77:../lib/usbdrv/asmcommon.inc ****     cpi     token, USBPID_IN    ;[27]
  78:../lib/usbdrv/asmcommon.inc ****     breq    handleIn            ;[28]
  79:../lib/usbdrv/asmcommon.inc ****     cpi     token, USBPID_SETUP ;[29]
  80:../lib/usbdrv/asmcommon.inc ****     breq    handleSetupOrOut    ;[30]
  81:../lib/usbdrv/asmcommon.inc ****     cpi     token, USBPID_OUT   ;[31]
  82:../lib/usbdrv/asmcommon.inc ****     brne    ignorePacket        ;[32] must be ack, nak or whatever
  83               	;   rjmp    handleSetupOrOut    ; fallthrough
  84               	
  85               	;Setup and Out are followed by a data packet two bit times (16 cycles) after
  86               	;the end of SE0. The sync code allows up to 40 cycles delay from the start of
  87               	;the sync pattern until the first bit is sampled. That's a total of 56 cycles.
  88               	handleSetupOrOut:               ;[32]
  89               	#if USB_CFG_IMPLEMENT_FN_WRITEOUT   /* if we have data for endpoint != 0, set usbCurrentTok to addr
  90               	    andi    x3, 0xf             ;[32]
  91               	    breq    storeTokenAndReturn ;[33]
  92               	    mov     token, x3           ;[34] indicate that this is endpoint x OUT
  93               	#endif
  94               	storeTokenAndReturn:
  95:../lib/usbdrv/asmcommon.inc ****     sts     usbCurrentTok, token;[35]
  96               	doReturn:
  97:../lib/usbdrv/asmcommon.inc ****     POP_STANDARD                ;[37] 12...16 cycles
  97 0158 3F91      	>  pop r19
  97 015a 5F91      	>  pop r21
  97 015c 4F91      	>  pop r20
  97 015e 1F91      	>  pop r17
  97 0160 0F91      	>  pop r16
  97 0162 2F91      	>  pop r18
  97 0164 6F91      	>  pop r22
  98:../lib/usbdrv/asmcommon.inc ****     USB_LOAD_PENDING(YL)        ;[49]
  99:../lib/usbdrv/asmcommon.inc ****     sbrc    YL, USB_INTR_PENDING_BIT;[50] check whether data is already arriving
 100:../lib/usbdrv/asmcommon.inc ****     rjmp    waitForJ            ;[51] save the pops and pushes -- a new interrupt is already pendin
 101               	sofError:
 102:../lib/usbdrv/asmcommon.inc ****     POP_RETI                    ;macro call
GAS LISTING /tmp/ccWbVCMv.s 			page 39


 102 016c DF91      	>  pop r29
 102 016e CF91      	>  pop r28
 102 0170 CFBF      	>  out ((0x3F)+0),r28
 102 0172 CF91      	>  pop r28
 103:../lib/usbdrv/asmcommon.inc ****     reti
 104               	
 105               	handleData:
 106               	#if USB_CFG_CHECK_CRC
 107               	    CRC_CLEANUP_AND_CHECK       ; jumps to ignorePacket if CRC error
 108               	#endif
 109:../lib/usbdrv/asmcommon.inc ****     lds     shift, usbCurrentTok;[18]
 110:../lib/usbdrv/asmcommon.inc ****     tst     shift               ;[20]
 111:../lib/usbdrv/asmcommon.inc ****     breq    doReturn            ;[21]
 112:../lib/usbdrv/asmcommon.inc ****     lds     x2, usbRxLen        ;[22]
 113:../lib/usbdrv/asmcommon.inc ****     tst     x2                  ;[24]
 114:../lib/usbdrv/asmcommon.inc ****     brne    sendNakAndReti      ;[25]
 115               	; 2006-03-11: The following two lines fix a problem where the device was not
 116               	; recognized if usbPoll() was called less frequently than once every 4 ms.
 117:../lib/usbdrv/asmcommon.inc ****     cpi     cnt, 4              ;[26] zero sized data packets are status phase only -- ignore and a
 118:../lib/usbdrv/asmcommon.inc ****     brmi    sendAckAndReti      ;[27] keep rx buffer clean -- we must not NAK next SETUP
 119               	#if USB_CFG_CHECK_DATA_TOGGLING
 120               	    sts     usbCurrentDataToken, token  ; store for checking by C code
 121               	#endif
 122:../lib/usbdrv/asmcommon.inc ****     sts     usbRxLen, cnt       ;[28] store received data, swap buffers
 123:../lib/usbdrv/asmcommon.inc ****     sts     usbRxToken, shift   ;[30]
 124:../lib/usbdrv/asmcommon.inc ****     lds     x2, usbInputBufOffset;[32] swap buffers
 125:../lib/usbdrv/asmcommon.inc ****     ldi     cnt, USB_BUFSIZE    ;[34]
 126:../lib/usbdrv/asmcommon.inc ****     sub     cnt, x2             ;[35]
 127:../lib/usbdrv/asmcommon.inc ****     sts     usbInputBufOffset, cnt;[36] buffers now swapped
 128:../lib/usbdrv/asmcommon.inc ****     rjmp    sendAckAndReti      ;[38] 40 + 17 = 57 until SOP
 129               	
 130               	handleIn:
 131               	;We don't send any data as long as the C code has not processed the current
 132               	;input data and potentially updated the output data. That's more efficient
 133               	;in terms of code size than clearing the tx buffers when a packet is received.
 134:../lib/usbdrv/asmcommon.inc ****     lds     x1, usbRxLen        ;[30]
 135:../lib/usbdrv/asmcommon.inc ****     cpi     x1, 1               ;[32] negative values are flow control, 0 means "buffer free"
 136:../lib/usbdrv/asmcommon.inc ****     brge    sendNakAndReti      ;[33] unprocessed input packet?
 137:../lib/usbdrv/asmcommon.inc ****     ldi     x1, USBPID_NAK      ;[34] prepare value for usbTxLen
 138               	#if USB_CFG_HAVE_INTRIN_ENDPOINT
 139:../lib/usbdrv/asmcommon.inc ****     andi    x3, 0xf             ;[35] x3 contains endpoint
 140               	#if USB_CFG_SUPPRESS_INTR_CODE
 141               	    brne    sendNakAndReti      ;[36]
 142               	#else
 143:../lib/usbdrv/asmcommon.inc ****     brne    handleIn1           ;[36]
 144               	#endif
 145               	#endif
 146:../lib/usbdrv/asmcommon.inc ****     lds     cnt, usbTxLen       ;[37]
 147:../lib/usbdrv/asmcommon.inc ****     sbrc    cnt, 4              ;[39] all handshake tokens have bit 4 set
 148:../lib/usbdrv/asmcommon.inc ****     rjmp    sendCntAndReti      ;[40] 42 + 16 = 58 until SOP
 149:../lib/usbdrv/asmcommon.inc ****     sts     usbTxLen, x1        ;[41] x1 == USBPID_NAK from above
 150:../lib/usbdrv/asmcommon.inc ****     ldi     YL, lo8(usbTxBuf)   ;[43]
 151:../lib/usbdrv/asmcommon.inc ****     ldi     YH, hi8(usbTxBuf)   ;[44]
 152:../lib/usbdrv/asmcommon.inc ****     rjmp    usbSendAndReti      ;[45] 57 + 12 = 59 until SOP
 153               	
 154               	; Comment about when to set usbTxLen to USBPID_NAK:
 155               	; We should set it back when we receive the ACK from the host. This would
GAS LISTING /tmp/ccWbVCMv.s 			page 40


 156               	; be simple to implement: One static variable which stores whether the last
 157               	; tx was for endpoint 0 or 1 and a compare in the receiver to distinguish the
 158               	; ACK. However, we set it back immediately when we send the package,
 159               	; assuming that no error occurs and the host sends an ACK. We save one byte
 160               	; RAM this way and avoid potential problems with endless retries. The rest of
 161               	; the driver assumes error-free transfers anyway.
 162               	
 163               	#if !USB_CFG_SUPPRESS_INTR_CODE && USB_CFG_HAVE_INTRIN_ENDPOINT /* placed here due to relative jump
 164               	handleIn1:                      ;[38]
 165               	#if USB_CFG_HAVE_INTRIN_ENDPOINT3
 166               	; 2006-06-10 as suggested by O.Tamura: support second INTR IN / BULK IN endpoint
 167               	    cpi     x3, USB_CFG_EP3_NUMBER;[38]
 168               	    breq    handleIn3           ;[39]
 169               	#endif
 170:../lib/usbdrv/asmcommon.inc ****     lds     cnt, usbTxLen1      ;[40]
 171:../lib/usbdrv/asmcommon.inc ****     sbrc    cnt, 4              ;[42] all handshake tokens have bit 4 set
 172:../lib/usbdrv/asmcommon.inc ****     rjmp    sendCntAndReti      ;[43] 47 + 16 = 63 until SOP
 173:../lib/usbdrv/asmcommon.inc ****     sts     usbTxLen1, x1       ;[44] x1 == USBPID_NAK from above
 174:../lib/usbdrv/asmcommon.inc ****     ldi     YL, lo8(usbTxBuf1)  ;[46]
 175:../lib/usbdrv/asmcommon.inc ****     ldi     YH, hi8(usbTxBuf1)  ;[47]
 176:../lib/usbdrv/asmcommon.inc ****     rjmp    usbSendAndReti      ;[48] 50 + 12 = 62 until SOP
 177               	
 252               	
 253               	; USB spec says:
 254               	; idle = J
 255               	; J = (D+ = 0), (D- = 1)
 256               	; K = (D+ = 1), (D- = 0)
 257               	; Spec allows 7.5 bit times from EOP to SOP for replies
 258               	; 7.5 bit times is 100 cycles. This implementation arrives a bit later at se0
 259               	; then specified in the include file but there is plenty of time
 260               	
 261               	bitstuffN:
 262:../lib/usbdrv/usbdrvasm20.inc ****     eor     x1, x4          ;[8]
 263:../lib/usbdrv/usbdrvasm20.inc ****     ldi     x2, 0           ;[9]
 264:../lib/usbdrv/usbdrvasm20.inc ****     nop2                    ;[10]
 265:../lib/usbdrv/usbdrvasm20.inc ****     out     USBOUT, x1      ;[12] <-- out
 266:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    didStuffN       ;[0]
 267               	    
 268               	bitstuff7:
 269:../lib/usbdrv/usbdrvasm20.inc ****     eor     x1, x4          ;[6]
 270:../lib/usbdrv/usbdrvasm20.inc ****     ldi     x2, 0           ;[7] Carry is zero due to brcc
 271:../lib/usbdrv/usbdrvasm20.inc ****     rol     shift           ;[8] compensate for ror shift at branch destination
 272:../lib/usbdrv/usbdrvasm20.inc ****     nop2                    ;[9]
 273:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    didStuff7       ;[11]
 274               	
 275               	sendNakAndReti:
 276:../lib/usbdrv/usbdrvasm20.inc ****     ldi     x3, USBPID_NAK  ;[-18]
 277:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    sendX3AndReti   ;[-17]
 278               	sendAckAndReti:
 279:../lib/usbdrv/usbdrvasm20.inc ****     ldi     cnt, USBPID_ACK ;[-17]
 280               	sendCntAndReti:
 281:../lib/usbdrv/usbdrvasm20.inc ****     mov     x3, cnt         ;[-16]
 282               	sendX3AndReti:
 283:../lib/usbdrv/usbdrvasm20.inc ****     ldi     YL, 20          ;[-15] x3==r20 address is 20
 284:../lib/usbdrv/usbdrvasm20.inc ****     ldi     YH, 0           ;[-14]
 285:../lib/usbdrv/usbdrvasm20.inc ****     ldi     cnt, 2          ;[-13]
 286               	;   rjmp    usbSendAndReti      fallthrough
GAS LISTING /tmp/ccWbVCMv.s 			page 41


 287               	
 288               	;usbSend:
 289               	;pointer to data in 'Y'
 290               	;number of bytes in 'cnt' -- including sync byte [range 2 ... 12]
 291               	;uses: x1...x4, btcnt, shift, cnt, Y
 292               	;Numbers in brackets are time since first bit of sync pattern is sent
 293               	;We don't match the transfer rate exactly (don't insert leap cycles every third
 294               	;byte) because the spec demands only 1.5% precision anyway.
 295               	usbSendAndReti:             ; 12 cycles until SOP
 296:../lib/usbdrv/usbdrvasm20.inc ****     in      x2, USBDDR      ;[-12]
 297:../lib/usbdrv/usbdrvasm20.inc ****     ori     x2, USBMASK     ;[-11]
 298:../lib/usbdrv/usbdrvasm20.inc ****     sbi     USBOUT, USBMINUS;[-10] prepare idle state; D+ and D- must have been 0 (no pullups)
 299:../lib/usbdrv/usbdrvasm20.inc ****     in      x1, USBOUT      ;[-8] port mirror for tx loop
 300:../lib/usbdrv/usbdrvasm20.inc ****     out     USBDDR, x2      ;[-7] <- acquire bus
 301               	; need not init x2 (bitstuff history) because sync starts with 0
 302:../lib/usbdrv/usbdrvasm20.inc ****     ldi     x4, USBMASK     ;[-6] exor mask
 303:../lib/usbdrv/usbdrvasm20.inc ****     ldi     shift, 0x80     ;[-5] sync byte is first byte sent
 304               	txByteLoop:
 305:../lib/usbdrv/usbdrvasm20.inc ****     ldi     bitcnt, 0x49    ;[-4]        [10] binary 01001001
 306               	txBitLoop:
 307:../lib/usbdrv/usbdrvasm20.inc ****     sbrs    shift, 0        ;[-3] [10]   [11]
 308:../lib/usbdrv/usbdrvasm20.inc ****     eor     x1, x4          ;[-2] [11]   [12]
 309:../lib/usbdrv/usbdrvasm20.inc ****     out     USBOUT, x1      ;[-1] [12]   [13]   <-- out N
 310:../lib/usbdrv/usbdrvasm20.inc ****     ror     shift           ;[0]  [13]   [14]
 311:../lib/usbdrv/usbdrvasm20.inc ****     ror     x2              ;[1]
 312               	didStuffN:
 313:../lib/usbdrv/usbdrvasm20.inc ****     nop2                    ;[2]
 314:../lib/usbdrv/usbdrvasm20.inc ****     nop                     ;[4]
 315:../lib/usbdrv/usbdrvasm20.inc ****     cpi     x2, 0xfc        ;[5]
 316:../lib/usbdrv/usbdrvasm20.inc ****     brcc    bitstuffN       ;[6]
 317:../lib/usbdrv/usbdrvasm20.inc ****     lsr     bitcnt          ;[7]
 318:../lib/usbdrv/usbdrvasm20.inc ****     brcc    txBitLoop       ;[8]
 319:../lib/usbdrv/usbdrvasm20.inc ****     brne    txBitLoop       ;[9]
 320               	
 321:../lib/usbdrv/usbdrvasm20.inc ****     sbrs    shift, 0        ;[10]
 322:../lib/usbdrv/usbdrvasm20.inc ****     eor     x1, x4          ;[11]
 323               	didStuff7:
 324:../lib/usbdrv/usbdrvasm20.inc ****     out     USBOUT, x1      ;[-1] [13] <-- out 7
 325:../lib/usbdrv/usbdrvasm20.inc ****     ror     shift           ;[0] [14]
 326:../lib/usbdrv/usbdrvasm20.inc ****     ror     x2              ;[1]
 327:../lib/usbdrv/usbdrvasm20.inc ****     nop                     ;[2]
 328:../lib/usbdrv/usbdrvasm20.inc ****     cpi     x2, 0xfc        ;[3]
 329:../lib/usbdrv/usbdrvasm20.inc ****     brcc    bitstuff7       ;[4]
 330:../lib/usbdrv/usbdrvasm20.inc ****     ld      shift, y+       ;[5]
 331:../lib/usbdrv/usbdrvasm20.inc ****     dec     cnt             ;[7]
 332:../lib/usbdrv/usbdrvasm20.inc ****     brne    txByteLoop      ;[8]
 333               	;make SE0:
 334:../lib/usbdrv/usbdrvasm20.inc ****     cbr     x1, USBMASK     ;[9] prepare SE0 [spec says EOP may be 25 to 30 cycles]
 335:../lib/usbdrv/usbdrvasm20.inc ****     lds     x2, usbNewDeviceAddr;[10]
 336:../lib/usbdrv/usbdrvasm20.inc ****     lsl     x2              ;[12] we compare with left shifted address
 337:../lib/usbdrv/usbdrvasm20.inc ****     out     USBOUT, x1      ;[13] <-- out SE0 -- from now 2 bits = 22 cycles until bus idle
 338:../lib/usbdrv/usbdrvasm20.inc ****     subi    YL, 20 + 2      ;[0] Only assign address on data packets, not ACK/NAK in x3
 339:../lib/usbdrv/usbdrvasm20.inc ****     sbci    YH, 0           ;[1]
 340               	;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
 341               	;set address only after data packet was sent, not after handshake
 342:../lib/usbdrv/usbdrvasm20.inc ****     breq    skipAddrAssign  ;[2]
 343:../lib/usbdrv/usbdrvasm20.inc ****     sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
GAS LISTING /tmp/ccWbVCMv.s 			page 42


 344               	skipAddrAssign:
 345               	;end of usbDeviceAddress transfer
 346:../lib/usbdrv/usbdrvasm20.inc ****     ldi     x2, 1<<USB_INTR_PENDING_BIT;[4] int0 occurred during TX -- clear pending flag
 347:../lib/usbdrv/usbdrvasm20.inc ****     USB_STORE_PENDING(x2)   ;[5]
 348:../lib/usbdrv/usbdrvasm20.inc ****     ori     x1, USBIDLE     ;[6]
 349:../lib/usbdrv/usbdrvasm20.inc ****     in      x2, USBDDR      ;[7]
 350:../lib/usbdrv/usbdrvasm20.inc ****     cbr     x2, USBMASK     ;[8] set both pins to input
 351:../lib/usbdrv/usbdrvasm20.inc ****     mov     x3, x1          ;[9]
 352:../lib/usbdrv/usbdrvasm20.inc ****     cbr     x3, USBMASK     ;[10] configure no pullup on both pins
 353:../lib/usbdrv/usbdrvasm20.inc ****     ldi     x4, 5           ;[11]
 354               	se0Delay:
 355:../lib/usbdrv/usbdrvasm20.inc ****     dec     x4              ;[12] [15] [18] [21] [24]
 356:../lib/usbdrv/usbdrvasm20.inc ****     brne    se0Delay        ;[13] [16] [19] [22] [25]
 357:../lib/usbdrv/usbdrvasm20.inc ****     out     USBOUT, x1      ;[26] <-- out J (idle) -- end of SE0 (EOP signal)
 358:../lib/usbdrv/usbdrvasm20.inc ****     out     USBDDR, x2      ;[27] <-- release bus now
 359:../lib/usbdrv/usbdrvasm20.inc ****     out     USBOUT, x3      ;[28] <-- ensure no pull-up resistors are active
 360:../lib/usbdrv/usbdrvasm20.inc ****     rjmp    doReturn
 361               	...
GAS LISTING /tmp/ccWbVCMv.s 			page 43


DEFINED SYMBOLS
../lib/usbdrv/usbdrvasm20.inc:49     .text:0000000000000032 __vector_1
../lib/usbdrv/usbdrvasm.S:233    .text:0000000000000000 usbCrc16
../lib/usbdrv/usbdrvasm.S:265    .text:000000000000002a usbCrc16Append
../lib/usbdrv/usbdrvasm.S:255    .text:0000000000000024 usbCrcLoopEntry
../lib/usbdrv/usbdrvasm.S:243    .text:0000000000000012 usbCrcByteLoop
../lib/usbdrv/usbdrvasm.S:246    .text:0000000000000016 usbCrcBitLoop
../lib/usbdrv/usbdrvasm.S:252    .text:0000000000000020 usbCrcNoXor
../lib/usbdrv/usbdrvasm.S:258    .text:0000000000000028 usbCrcReady
../lib/usbdrv/usbdrvasm20.inc:63     .text:000000000000003a waitForJ
../lib/usbdrv/usbdrvasm20.inc:67     .text:0000000000000040 waitForK
../lib/usbdrv/usbdrvasm20.inc:96     .text:0000000000000066 foundK
../lib/usbdrv/asmcommon.inc:101    .text:000000000000016c sofError
../lib/usbdrv/usbdrvasm20.inc:125    .text:0000000000000084 haveTwoBitsK
../lib/usbdrv/usbdrvasm20.inc:135    .text:0000000000000096 bit0
../lib/usbdrv/usbdrvasm20.inc:208    .text:00000000000000f8 handleBit
../lib/usbdrv/usbdrvasm20.inc:144    .text:000000000000009c b6checkUnstuff
../lib/usbdrv/usbdrvasm20.inc:182    .text:00000000000000d2 unstuff6
../lib/usbdrv/usbdrvasm20.inc:147    .text:00000000000000a0 bit7
../lib/usbdrv/asmcommon.inc:43     .text:000000000000011a overflow
../lib/usbdrv/usbdrvasm20.inc:166    .text:00000000000000c2 b7handle0
../lib/usbdrv/usbdrvasm20.inc:186    .text:00000000000000d8 unstuff
../lib/usbdrv/usbdrvasm20.inc:204    .text:00000000000000f2 bitloop
../lib/usbdrv/asmcommon.inc:55     .text:0000000000000122 se0
../lib/usbdrv/usbdrvasm20.inc:221    .text:000000000000010e handle0
../lib/usbdrv/asmcommon.inc:46     .text:000000000000011e ignorePacket
../lib/usbdrv/asmcommon.inc:94     .text:0000000000000154 storeTokenAndReturn
../lib/usbdrv/asmcommon.inc:105    .text:0000000000000176 handleData
../lib/usbdrv/asmcommon.inc:130    .text:00000000000001a0 handleIn
../lib/usbdrv/asmcommon.inc:88     .text:0000000000000154 handleSetupOrOut
../lib/usbdrv/asmcommon.inc:96     .text:0000000000000158 doReturn
../lib/usbdrv/usbdrvasm20.inc:275    .text:00000000000001e6 sendNakAndReti
../lib/usbdrv/usbdrvasm20.inc:278    .text:00000000000001ea sendAckAndReti
../lib/usbdrv/asmcommon.inc:164    .text:00000000000001c0 handleIn1
../lib/usbdrv/usbdrvasm20.inc:280    .text:00000000000001ec sendCntAndReti
../lib/usbdrv/usbdrvasm20.inc:295    .text:00000000000001f4 usbSendAndReti
../lib/usbdrv/usbdrvasm20.inc:261    .text:00000000000001d2 bitstuffN
../lib/usbdrv/usbdrvasm20.inc:312    .text:000000000000020e didStuffN
../lib/usbdrv/usbdrvasm20.inc:268    .text:00000000000001dc bitstuff7
../lib/usbdrv/usbdrvasm20.inc:323    .text:0000000000000220 didStuff7
../lib/usbdrv/usbdrvasm20.inc:282    .text:00000000000001ee sendX3AndReti
../lib/usbdrv/usbdrvasm20.inc:304    .text:0000000000000202 txByteLoop
../lib/usbdrv/usbdrvasm20.inc:306    .text:0000000000000204 txBitLoop
../lib/usbdrv/usbdrvasm20.inc:344    .text:0000000000000246 skipAddrAssign
../lib/usbdrv/usbdrvasm20.inc:354    .text:0000000000000256 se0Delay

UNDEFINED SYMBOLS
usbInputBufOffset
usbRxBuf
usbDeviceAddr
usbCurrentTok
usbRxLen
usbRxToken
usbTxLen
usbTxBuf
usbTxStatus1
usbNewDeviceAddr
GAS LISTING /tmp/ccWbVCMv.s 			page 44


